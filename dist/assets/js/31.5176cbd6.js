(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{452:function(a,t,e){a.exports=e.p+"assets/img/file-upload.bcc85f85.png"},581:function(a,t,e){"use strict";e.r(t);var s=e(28),n=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"前端实现大文件上传"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端实现大文件上传"}},[a._v("#")]),a._v(" 前端实现大文件上传")]),a._v(" "),s("h2",{attrs:{id:"背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[a._v("#")]),a._v(" 背景")]),a._v(" "),s("p",[a._v("如果前端要实现超大文件（几个G）上传怎么办? 对于浏览器而言普通文件上传只是通过一个\n链接进行数据传输，如果文件太大，可想而知比较耗时且容易失败失败了还的重新上传。")]),a._v(" "),s("h2",{attrs:{id:"技术方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#技术方案"}},[a._v("#")]),a._v(" 技术方案")]),a._v(" "),s("p",[a._v("如果能够将文件进行切割成些许小碎片, 例如将1G的文件切割成11份，按照一定顺序进行排序，\n然后利用浏览器一次能够同时并发4-8个请求的方式，将这11份小文件碎片进行请求发送到后端，\n上传完之后在将文件碎片进行重组成一个完整的文件，上传速度能够提升4-8倍；")]),a._v(" "),s("p",[s("img",{attrs:{src:e(452),alt:"avatar"}})]),a._v(" "),s("h3",{attrs:{id:"文件如何进行切分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件如何进行切分"}},[a._v("#")]),a._v(" 文件如何进行切分")]),a._v(" "),s("p",[a._v("文件对象是Blob类型，使用slice进行切割")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("// 生成文件切片\ncreateFileChunk(file, size=SIZE) {\n    const fileChunkList = [];\n    let cur = 0;\n    while(cur < file.size) {\n        fileChunkList.push({file: file.slice(cur, cur+size)});\n        cur += size;\n    }\n    return fileChunkList;\n},\n")])])]),s("p",[a._v("然后只需要将这些碎片并行发送请求，待请求发送完成之后，在发送合并请求，通知服务进行文件合并。")]),a._v(" "),s("h3",{attrs:{id:"如何做断点续传"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何做断点续传"}},[a._v("#")]),a._v(" 如何做断点续传")]),a._v(" "),s("p",[a._v("上面已经完成了对文件的切割, 那么如何对文件片做唯一标示呢？\n我们需要根据文件内容生成唯一hash, 然后使用hash+index作为每一个文件碎片的标示，\n这样做的一个好处就是能把每个文件区分开，如果由于网络原因导致某些文件件碎片上传失败\n支需要去过滤调上传成功的碎片，然后上传没上传成功的碎片。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('// 上传切片\nasync uploadChunks(uploadedList = []) {\n    const requestList = this.fileData.filter(({ hash }) => !uploadedList.includes(hash))\n        .map(({chunk, hash, index}) => {\n        const formData = new FormData;\n            formData.append("chunk", chunk);\n            formData.append("hash", hash);\n            formData.append("filename", this.container.file.name);\n            formData.append("fileHash", this.container.hash);\n            return {formData, index};\n    }).map(async({formData, index}) => xhrFun({  \n            url: "http://localhost:3000",\n            data: formData, \n            onProgress: this.createProgressHandler(this.fileData[index]),\n            requestList: this.requestList\n        }));\n    await Promise.all(requestList); // 并发切片\n    await this.mergeRequest();\n},\n')])])]),s("h3",{attrs:{id:"文件被切碎之后怎么合并成完整的文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文件被切碎之后怎么合并成完整的文件"}},[a._v("#")]),a._v(" 文件被切碎之后怎么合并成完整的文件")]),a._v(" "),s("p",[a._v("由于使用了hash和index作为文件的标示，因此可以在文件碎片上传完之后，直接发送请求通知服务端去完成文件合并的动作（只需要根据文件碎片名index去按顺序合并）")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('// 合并切片\nconst mergeFileChunk = async (filePath, fileHash, size) => {\n  const chunkDir = path.resolve(UPLOAD_DIR, fileHash);\n  const chunkPaths = await fse.readdir(chunkDir);\n  // 根据切片下标进行排序\n  // 否则直接读取目录的获得的顺序可能会错乱\n  chunkPaths.sort((a, b) => a.split("-")[1] - b.split("-")[1]);\n  await Promise.all(\n    chunkPaths.map((chunkPath, index) =>\n      pipeStream(\n        path.resolve(chunkDir, chunkPath),\n        // 指定位置创建可写流\n        fse.createWriteStream(filePath, {\n          start: index * size,\n          end: (index + 1) * size\n        })\n      )\n    )\n  );\n  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录\n};\n')])])]),s("p",[a._v("以上具体实现源码可以参考")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/EvalGitHub/vue-study/blob/master/src/views/upload_file/index.vue",target:"_blank",rel:"noopener noreferrer"}},[a._v("前端代码"),s("OutboundLink")],1),a._v("， "),s("a",{attrs:{href:"https://github.com/EvalGitHub/vue-study/blob/master/server/index.js",target:"_blank",rel:"noopener noreferrer"}},[a._v("node服务"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"阿里云方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阿里云方案"}},[a._v("#")]),a._v(" 阿里云方案")]),a._v(" "),s("p",[a._v("对于这种常见的大文件上传需求，阿里云提供了比较好的"),s("a",{attrs:{href:"https://help.aliyun.com/document_detail/64047.htm?spm=a2c4g.11186623.2.16.5a9423f2whOqN0#section-snl-fxt-4fb",target:"_blank",rel:"noopener noreferrer"}},[a._v("解决方案"),s("OutboundLink")],1),a._v("。")]),a._v(" "),s("p",[a._v("通过这种方式只需要申请几个oss参数，简单封装即可。")])])}),[],!1,null,null,null);t.default=n.exports}}]);