(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{415:function(v,_,t){v.exports=t.p+"assets/img/tcp.28fb8499.png"},416:function(v,_,t){v.exports=t.p+"assets/img/udp.5ed9fdce.png"},507:function(v,_,t){"use strict";t.r(_);var p=t(28),s=Object(p.a)({},(function(){var v=this,_=v.$createElement,p=v._self._c||_;return p("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[p("h1",{attrs:{id:"tcp与udp"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp"}},[v._v("#")]),v._v(" tcp与udp")]),v._v(" "),p("p",[v._v("TCP/IP具有两个具有代表性的传输层控制层协议tcp，udp")]),v._v(" "),p("ul",[p("li",[v._v("tcp：传输控制协议（transmission control protocol）")]),v._v(" "),p("li",[v._v("udp: 用户数据报协议（user datagram protocol）")])]),v._v(" "),p("p",[v._v("IP首部有个协议字段用来标识网络层的上一层所采用的是哪一种传输控制协议")]),v._v(" "),p("h2",{attrs:{id:"tcp"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),p("p",[v._v("通过[源，目标]ip地址，[源，目标]端口号，协议号进行通信识别")]),v._v(" "),p("p",[v._v("TCP是面向连接的可靠的流协议，实行“顺序控制”或“重发控制”，“流量控制”，“拥塞控制”，提高网络利用率")]),v._v(" "),p("p",[p("strong",[v._v("tcp如何保证可靠性？")])]),v._v(" "),p("p",[v._v("在tcp中发送端的数据到达接受主机时候，接受主机会返回一个收到的消息通知。这个消息叫做"),p("strong",[v._v("确认应答")]),v._v("；\n如果在一定时间内没有收到确认应答，发送端就认为是数据丢失，会进行重发。")]),v._v(" "),p("ul",[p("li",[v._v("但是存在一个问题？？")])]),v._v(" "),p("p",[v._v("如果接收端已经收到了数据，只是返回"),p("strong",[v._v("确认应答")]),v._v("的时候没能成功，使得发送端重复发送数据，这样接收端需要放弃重复的数据包，为此"),p("strong",[v._v("序列号")]),v._v("就出现了。")]),v._v(" "),p("p",[v._v("序列号是按顺序给数据的每一个字节都标上号码的编号，接收端查询数据TCP首部序列号和数据长度，将自己下一步应该接受序列号作为确认应答返回去。")]),v._v(" "),p("blockquote",[p("p",[v._v("MSS 最大消息长度，在建立tcp链接时，确定的发送数据包的单位，两端发出建立链接请求时，会在tcp首部写入MSS选项，告诉对方能接受MSS大小，然后在两端的mss中取较小的值投入使用。")])]),v._v(" "),p("p",[p("strong",[v._v("什么是窗口控制？")])]),v._v(" "),p("p",[v._v("Tcp每发一个段进行一次确认应答的处理，这种方式效率特别低，因此引入了“窗口控制”，\n确认应答不再是以每个分段而是以更大的单位进行，（在发送一个段以后不必等待确认应答而是继续发送）\n使用大量缓冲区，通过对多个段同时进行确认应答的功能，在发送端收到确认应答之前，必须在缓冲区保存所有\n的数据。")]),v._v(" "),p("p",[p("strong",[v._v("什么是流控制？")])]),v._v(" "),p("p",[v._v("当接收端处于高负荷的情况下会无法接受数据，造成发送端的数据无法被接受，触发重发机制，造成流量浪费。\n因此tcp可以根据接收端的数据接收能力来控制发送的数据量。\n（TCP首部中会有个专门的字段用来告诉发送端接收端的缓存区的大小）")]),v._v(" "),p("p",[p("strong",[v._v("什么是拥塞控制？")])]),v._v(" "),p("p",[v._v("当网络出现拥堵时，如果突然发送一个较大的数据，可能会导致网络的瘫痪，为了防止这个问题，在通信的开始通过\n一个叫做"),p("strong",[v._v("慢启动")]),v._v("的算法对发送数据量进行控制；同时还定义了“拥塞窗口”。\n首先拥塞窗口的大小设置为1MSS，之后每次收到一个确认应答（ACK），拥塞窗口的值就加1，\n在发送数据时需要将拥塞窗口的大小与接收端的通知窗口（流量窗口）大小作比较，选择其小值来发送数据。")]),v._v(" "),p("h3",{attrs:{id:"tcp数据格式"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#tcp数据格式"}},[v._v("#")]),v._v(" TCP数据格式")]),v._v(" "),p("p",[p("img",{attrs:{src:t(415),alt:"avatar"}})]),v._v(" "),p("p",[v._v("首部格式？")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("源端口号")])]),v._v(" "),p("li",[p("p",[v._v("目标端口号")])]),v._v(" "),p("li",[p("p",[v._v("序列号（sequence number）\n字段长32位，指发送数据的位置，每发送一次数据，就累加一次该数据字节数的大小。\n（建立链接时候，由计算机生成随机数作为初始值）")])]),v._v(" "),p("li",[p("p",[v._v("确认应答号(acknowledgement number)\n发送端收到这个确认号以后可以认为这个序列号以前的数据已经被正常接受")])]),v._v(" "),p("li",[p("p",[v._v("数据偏移\nTCP首部的长度（表示TCP所传输的数据应该从TCP包的那个位置开始）")])]),v._v(" "),p("li",[p("p",[v._v("窗口大小\n接受端当前能接受的最大数据量，TCP不允许发送超过这个大小的数据；如果窗口大小为0，发送端会进行窗口探测，了解最新的\n窗口大小")])]),v._v(" "),p("li",[p("p",[v._v("控制位")])])]),v._v(" "),p("p",[v._v("字段长度为8，每一位从左到右分别为CWR，ECE，URG，ACK，PSH，RST，SYN，FIN\n这些标志也称之为控制位")]),v._v(" "),p("p",[v._v("cwr（congestion window reduced）为1，通知对方已将用塞窗口缩小")]),v._v(" "),p("p",[v._v("ACK为1表示确认应达的字段有效")]),v._v(" "),p("p",[v._v("SYN（synchronize flag） 为1表示希望建立链接")]),v._v(" "),p("p",[v._v("FIN（fin flag） 表示今后不会有数据发送，断开链接")]),v._v(" "),p("ul",[p("li",[v._v("校验和")])]),v._v(" "),p("h2",{attrs:{id:"udp"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[v._v("#")]),v._v(" UDP")]),v._v(" "),p("p",[v._v("udp是一种不可靠的数据传输协议，不能保证数据一定会到达目标节点，都是交给应用自行处理\nudp常用于高速传输和实时性要求较高的通信或广播通信")]),v._v(" "),p("h3",{attrs:{id:"udp数据格式"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#udp数据格式"}},[v._v("#")]),v._v(" UDP数据格式")]),v._v(" "),p("p",[v._v("upd数据格式包括：udp首部，以及数据部分")]),v._v(" "),p("p",[p("img",{attrs:{src:t(416),alt:"avatar"}})]),v._v(" "),p("p",[v._v("首部格式？")]),v._v(" "),p("ul",[p("li",[p("p",[v._v("源端口号\n在不需要返回的通信中源端口设置为0")])]),v._v(" "),p("li",[p("p",[v._v("目标端口号")])]),v._v(" "),p("li",[p("p",[v._v("包长度\n保存了UDP首部的长度和数据长度之和")])]),v._v(" "),p("li",[p("p",[v._v("校验和\n校验和是为了提供可靠的upd首部和数据长度之和而设计")])])]),v._v(" "),p("p",[p("strong",[v._v("UDP伪首部？")])]),v._v(" "),p("p",[v._v("接收端在进行校验和计算时，需要从IP首部获取IP地址（源，目标ip地址，协议号）构造"),p("strong",[v._v("UDP伪首部")]),v._v("，用来校验计算。\n(如果源，目标ip地址，协议号这些信息被破坏，就会使得包不能被正确收到，可能收到的包不是发送端发送的)")]),v._v(" "),p("h2",{attrs:{id:"端口号如何确定"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#端口号如何确定"}},[v._v("#")]),v._v(" 端口号如何确定")]),v._v(" "),p("p",[v._v("在进行通信时，要事先定义端口，端口号的确定有两种方法：")]),v._v(" "),p("ul",[p("li",[v._v("标准既定端口号")])]),v._v(" "),p("p",[v._v("每个应用程序都有指定的端口号，每个端口号都有其使用目的\nem: http 80 ，https 443 ，")]),v._v(" "),p("ul",[p("li",[v._v("时序分配法")])]),v._v(" "),p("p",[v._v("客户端完全不用设置端口号，而是全权交给操作系统分配")])])}),[],!1,null,null,null);_.default=s.exports}}]);