(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{430:function(t,e,n){t.exports=n.p+"assets/img/set_state.2be1faeb.png"},541:function(t,e,n){"use strict";n.r(e);var a=n(28),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"对setstate的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对setstate的理解"}},[t._v("#")]),t._v(" 对setState的理解")]),t._v(" "),a("h3",{attrs:{id:"_1-setstate的异步机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-setstate的异步机制"}},[t._v("#")]),t._v(" 1.setState的异步机制？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Root extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n  componentDidMount() {\n    let me = this;\n    me.setState({\n      count: me.state.count + 1\n    });\n    console.log(me.state.count);    // 打印\n    me.setState({\n      count: me.state.count + 1\n    });\n    console.log(me.state.count);    // 打印\n    setTimeout(function(){\n     console.log(me.state.count);   // 打印\n    }, 0);\n    setTimeout(function(){\n     me.setState({\n       count: me.state.count + 1\n     });\n     console.log(me.state.count);   // 打印\n    }, 0);\n    setTimeout(function(){\n     me.setState({\n       count: me.state.count + 1\n     });\n     console.log(me.state.count);   // 打印\n    }, 0);\n  }\n  render() {\n    return (\n      <h1>{this.state.count}</h1>\n    )\n  }\n}\n")])])]),a("blockquote",[a("p",[t._v("答案： 0, 0, 1, 2, 3")])]),t._v(" "),a("p",[t._v("执行setState并不能立即获得我们的期望state值，因为setState是异步执行的，并不会立即执行，所以不能同步获取，并且正是因为他的异步，所以多次连续的执行setState，只会执行最后一次的setState。\nthis.setState((\ntarget: newValue\n), () => {\nconsole.log(this.state,target);\n})\nwhy?：但是问题是为啥在setTimeout/setInterval中却能同步获取我们想要的值呢？\nreason：在React内部机制能检测到的地方， setState就是异步的；在React检测不到的地方（非合成事件，非生命周期中），例如setInterval,setTimeout，原生事件里，setState就是同步更新的。")]),t._v(" "),a("h3",{attrs:{id:"_2-setstate更新状态的机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-setstate更新状态的机制"}},[t._v("#")]),t._v(" 2.setState更新状态的机制？")]),t._v(" "),a("p",[t._v("this.setState()不仅会改变组件的当前状态【返回一个新状态，使用了Object.assign(),将已修改的属性添加进去，而不是覆盖】，还会触发组件的render(),更新view")]),t._v(" "),a("h3",{attrs:{id:"_3-setstate更新状态总是会触发render-刷新视图吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-setstate更新状态总是会触发render-刷新视图吗"}},[t._v("#")]),t._v(" 3.setState更新状态总是会触发render()刷新视图吗？")]),t._v(" "),a("p",[t._v("会，每一个setState如果不做特殊操作都会触发视图的更新（无论值是否改变）， 因为componentWillUpdate -> shouldComponentUpdate(nextProps, nextState) 默认是返回true -> render ; 因此可以可以在shouldComponentUpdate中进行react优化（判断this.state与nextState是否相等）")]),t._v(" "),a("h3",{attrs:{id:"_4-多次执行this-setstate-的操作-而且都是同一属性修改最终会以那次为准"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-多次执行this-setstate-的操作-而且都是同一属性修改最终会以那次为准"}},[t._v("#")]),t._v(" 4.多次执行this.setState()的操作， 而且都是同一属性修改最终会以那次为准？")]),t._v(" "),a("p",[t._v('setState的批量优化更新优化只是建立在"异步"(合成事件，钩子函数)上， 在原生事件和setTimeout中不会批量更新；多次连续对同一个值执行setSate,setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会进行合并批量更新。')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" this.state = {\n\ttestCount: 1\n };\n componentDidMount () {\n    this.setState({\n      testCount: 1+ this.state.testCount,\n    });\n    \n    this.setState({\n      testCount: 2 + this.state.testCount,\n    });\n    this.setState({\n      testCount: 3 + this.state.testCount,\n    });\n    setTimeout(() => console.log(this.state.testCount))\n  };\n")])])]),a("blockquote",[a("p",[t._v("结果：4")])]),t._v(" "),a("h3",{attrs:{id:"_5-setstate为啥要设计成异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-setstate为啥要设计成异步"}},[t._v("#")]),t._v(" 5.setState为啥要设计成异步？")]),t._v(" "),a("p",[t._v("前提：首先需要确认的是延时setState对状态变动进行批量更新可以提升执行效率\nsetState异步执行，等待其他变动一起修改state，然后同步渲染view")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("保证内部的一致性:")]),t._v("\n即使state可以同步更新，但是props也不能。试想一种情况：子组件通过props获 取父组件的state上的属性值。因为上述前提的存在，即使state的同步更新，也不会频繁触发视图的更新，使得props不能同步state的值，导致父组件中的state值与子组件中的props值不相同的情况。")])]),t._v(" "),a("p",[t._v("个人觉得是为了提升执行效率而带来的结果")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("异步更新使得并发更新组件成为可能：")]),t._v("\n首先我们在这里讨论是否同步刷新state有一个前提那就是我们默认更新节点是遵循特定的顺序的。但是按默认顺序更新组件在以后的react中可能就变了。\n举个例子：比如你现在正在打字，那么TextBox组件需要实时的刷新。但是当你在输入的时候，来了一个信息，这个时候，可能让信息延后刷新可能更符合交互。")])]),t._v(" "),a("p",[t._v("这个理由，可能是react发展的一个方向，目前还没有实现。")]),t._v(" "),a("h3",{attrs:{id:"_6-简单说下setstate的异步原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-简单说下setstate的异步原理"}},[t._v("#")]),t._v(" 6.简单说下setState的异步原理？")]),t._v(" "),a("p",[t._v("当调用setState时候，实际上使用enqueueSetState方法对partialState和_pendingStateQueue更新队列进行合并操作，最终通过enqueueUpdate执行state更新。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("enqueueSetState: function(publicInstance, partialState) {\n var internalInstance = getInternalInstanceReadyForUpdate(\n publicInstance,\n 'setState'\n );\n if (!internalInstance) {\n return;\n }\n // 更新队列合并操作\n var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n queue.push(partialState);\n enqueueUpdate(internalInstance);\n}, \n")])])]),a("p",[a("img",{attrs:{src:n(430),alt:"avatar"}})]),t._v(" "),a("p",[t._v("关于enqueueUpdate的简单源码实现“")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function enqueueUpdate(component) {\n  ensureInjected();\n  // 如果不处于批量更新模式\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n    }\n    // 如果处于批量更新模式，则将该组件保存在 dirtyComponents 中\n    dirtyComponents.push(component);\n  }\n}\n")])])]),a("p",[t._v("如果 isBatchingUpdates 为 true，则对所有队列中的更新执行 batchedUpdates 方法，否则只\n把当前组件（即调用了 setState 的组件）放入 dirtyComponents 数组中。")]),t._v(" "),a("h3",{attrs:{id:"_7-为什么react需要shouldcomponentupdate而vue不需要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么react需要shouldcomponentupdate而vue不需要"}},[t._v("#")]),t._v(" 7.为什么react需要shouldComponentUpdate而vue不需要？？")]),t._v(" "),a("p",[t._v("因为react是diff dom, vue是diff数据，在react中整个框架并不能自己知道数据是否发生了变化，只能通过开发者手动的setState，然后react内部将这个动作放入_penddingStateEquenu中，然后在循环执行，\n然后对应的就是虚拟dom的修改，通过diff算法去更新dom；但是在vue中每当数据的修改都会触发对象属性描述方法set，进而就会触发一个notify(如果没做修改则不会触发)，然后去创建虚拟dom，进而更新视图。\n总体描述：在react中是开发者手动去setSate继而更新视图，vue中只要数据变了就会触发视图更新，他们的实现方式也就注定了这个api的存在与否。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.zhihu.com/question/266656197",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考文档"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/facebook/react/issues/11527",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/facebook/react/issues/11527"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5a6f440a51882573336652af",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://juejin.im/post/5a6f440a51882573336652af"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/cc12e9a8052c",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.jianshu.com/p/cc12e9a8052c"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);