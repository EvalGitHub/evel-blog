(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{542:function(t,n,e){"use strict";e.r(n);var s=e(28),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"setstate的异步分析及实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate的异步分析及实现原理"}},[t._v("#")]),t._v(" setState的异步分析及实现原理")]),t._v(" "),e("p",[t._v("在react中如果要实现当前组件的view更新，必须手动调用setState，forceUpdate")]),t._v(" "),e("ul",[e("li",[t._v("setState，forceUpdate使用场景及区别")])]),t._v(" "),e("p",[t._v("forceUpdate会导致组件重新执行render渲染，跳过shouldComponentUpdate，\n在父子组件之间相互传递props的时候，如果子组件使用了shouleComponentUpdate/pureComponent优化手段，\n父组件传递的props过于复杂，即使props更新了，子组件也可能不会进行更新（因为shouleComponentUpdate使用的\n是浅比较），这个时候可以在子组件中使用forceUpdate来进行重新render。")]),t._v(" "),e("h2",{attrs:{id:"setstate的异步更新思想"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#setstate的异步更新思想"}},[t._v("#")]),t._v(" setState的异步更新思想")]),t._v(" "),e("p",[t._v("在执行setState更新一个状态之后，如果在react的合成事件，以及生命周期函数中直接获取这个更新的state，会发现\n最终的结果还是没有更新之前的结果，组件也只会渲染一次。（如果是在原生事件中会获得最新的结果）")]),t._v(" "),e("p",[t._v("说说结果并解析下原因\n``"),e("br"),t._v("\nthis.state = {\nnum: 0,\nnum2: 0,\nvalue: 2\n};\ntest = () => {\nfor (let i = 0; i < 3; i++) {\nthis.setState(prevState => {\nreturn {\nnum: prevState.num + 1\n};\n});\nthis.setState({\nnum2: this.state.num2 + 1\n});\nconsole.log('num2', this.state.num2);\nconsole.log('num', this.state.num);\n}\nsetTimeout(() => {\nthis.setState({\nnum3: 2\n});\nconsole.log('num3', this.state.num3);\n});\n};\nrender() {\n")]),e("div",{attrs:{className:"App"}},[e("p",[t._v("\n{this.state.num}---{this.state.num2}\n")]),t._v(" "),e("button",{attrs:{onClick:"{this.test}"}},[t._v("test")])]),t._v("\n}"),e("p"),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("\n> num2 0, \n  num 0\n  num2 0, \n  num 0\n  num2 0, \n  num 0\n\n  num3 2\n\n> 最终的界面显示：3 --- \n\n[demo例子](https://codesandbox.io/s/setstatedeyibusixiang-b248j)\n\n- 分析：setState是异步执行的，并且test是react的合成事件，因此在不能立即获取最新的执行结果，所有num2,num都是0；而setTimeout\n是非合成事件尽管setState异步但是仍然能立即获取最新值；关于setSate的两种使用形式一种是传入函数（可以获取当前state之前的state），\n一种是传递对象。\n\n**思考拓展**\n\n")])])]),e("p",[t._v('test = () => {\nfor (let i = 0; i < 10; i++) {\nthis.setState({\nnum: this.state.num + 1\n});\nthis.setState(prevState => {\nreturn {\nnum: prevState.num + 1\n};\n});\nconsole.log("num", this.state.num);\n}\n}')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("如果改成这样结果是什么样呢？\n\n>  2\n\n分析：因为第一个setState在执行的时候，总是会将num置为1，所以不管遍历多少次最终的返回结果都是第二个setState 加 1 返回 2\n\n## 为什么setState要是异步？？\n\n异步的原因：\n  - 性能优化，减少不必要的渲染，提升用户体验\n  - 即使state能做到同步更新，但是props不能\n\nhttps://github.com/facebook/react/issues/11527\n\n## setSate的简单实现\n\nhttps://zhuanlan.zhihu.com/p/44537887\n\n\n\n\n\n\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);