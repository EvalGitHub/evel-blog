(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{429:function(e,t,a){e.exports=a.p+"assets/img/react-diff.e2060a80.png"},537:function(e,t,a){"use strict";a.r(t);var n=a(28),v=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"react的diff过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react的diff过程"}},[e._v("#")]),e._v(" react的diff过程")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。")])]),e._v(" "),n("li",[n("p",[e._v("拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。")])]),e._v(" "),n("li",[n("p",[e._v("对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。")])])]),e._v(" "),n("p",[n("strong",[e._v("react的diff分三个策略：tree diff, component diff, element diff")])]),e._v(" "),n("h2",{attrs:{id:"tree-diff"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#tree-diff"}},[e._v("#")]),e._v(" tree diff")]),e._v(" "),n("p",[e._v("对树的分层比较，两个树只对同一层节点进行比较；如果节点不存在\n则该节点及其子节点完全被删除，不会进行下一步的比较。")]),e._v(" "),n("h2",{attrs:{id:"component-diff"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#component-diff"}},[e._v("#")]),e._v(" component diff")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("同一类型组件，按照层级比较Virture DOM树；如能知道组件没有发生变化，能节省大量\n计算时间。（通过shouldComponentUpdate，React.memo）")])]),e._v(" "),n("li",[n("p",[e._v("不同类型的组件直接替换新建。")])])]),e._v(" "),n("h2",{attrs:{id:"element-diff"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#element-diff"}},[e._v("#")]),e._v(" element diff")]),e._v(" "),n("p",[e._v("对同一层级的一组子节点，通过id区分")]),e._v(" "),n("p",[e._v("当节点处于同一层级时，diff提供了三种节点操作："),n("strong",[e._v("删除，插入，移动")])]),e._v(" "),n("p",[e._v("em：现已存在集合（A,B,C,D）")]),e._v(" "),n("ul",[n("li",[e._v("插入")])]),e._v(" "),n("p",[e._v("新的节点E不在集合中，需要将其插入")]),e._v(" "),n("ul",[n("li",[e._v("删除")])]),e._v(" "),n("p",[e._v("现在的新的集合成了（A,B）,组件D不在其中了需要对其进行删除")]),e._v(" "),n("ul",[n("li",[e._v("移动")])]),e._v(" "),n("p",[e._v("新的集合变成了（A,D,B,C）, D只是位置发生了更新。")]),e._v(" "),n("p",[e._v("如果没有添加唯一的key值，这时候需要使用旧的集合的B与新集合D进行比较，删除第二个位置的B，再将D插入到第二个位置")]),e._v(" "),n("p",[e._v("但是如果使用了唯一的key，则只需将B，D位置替换即可。")]),e._v(" "),n("p",[n("img",{attrs:{src:a(429),alt:"avatar"}})]),e._v(" "),n("blockquote",[n("p",[e._v("（1）看着上图的 B，React先从新中取得B，然后判断旧中是否存在相同节点B，当发现存在节点B后，就去判断是否移动B。\nB在旧 中的index=1，它的lastIndex=0，不满足 index < lastIndex 的条件，因此 B 不做移动操作。此时，一个操作是，lastIndex=(index,lastIndex)中的较大数=1.")])]),e._v(" "),n("blockquote",[n("p",[e._v("（2）看着 A，A在旧的index=0，此时的lastIndex=1，满足index<lastIndex，对A进行移动操作，此时lastIndex=max(index,lastIndex)=1。")])]),e._v(" "),n("blockquote",[n("p",[e._v("（3）看着D，同（1），不移动，由于D在旧的index=3，比较时，lastIndex=1，所以改变lastIndex=max(index,lastIndex)=3")])]),e._v(" "),n("blockquote",[n("p",[e._v("（4）看着C，同（2），移动，C在旧的index=2，满足index<lastIndex（lastIndex=3），所以移动。")])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/20346379",target:"_blank",rel:"noopener noreferrer"}},[e._v("React 源码剖析系列 － 不可思议的 react diff"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=v.exports}}]);