(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{516:function(e,a,n){"use strict";n.r(a);var t=n(28),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"typescript的高级技巧用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#typescript的高级技巧用法"}},[e._v("#")]),e._v(" TypeScript的高级技巧用法")]),e._v(" "),n("h2",{attrs:{id:"联合类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#联合类型"}},[e._v("#")]),e._v(" 联合类型")]),e._v(" "),n("blockquote",[n("p",[e._v("let a: string | number = '123'  // 变量a的类型既可以是string，也可以是number\na = 123")])]),e._v(" "),n("h2",{attrs:{id:"keyof"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#keyof"}},[e._v("#")]),e._v(" keyof")]),e._v(" "),n("p",[e._v("将一个类型的属性名全部提取出来当做联合类型")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  name: string;\n  age: number;\n }\ntype PersonAttribute = keyof Person; \n// 类似于 type PersonAttribute = 'name' | 'age'\n")])])]),n("h2",{attrs:{id:"record"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#record"}},[e._v("#")]),e._v(" Record")]),e._v(" "),n("p",[e._v("Record用于属性映射")]),e._v(" "),n("ol",[n("li",[e._v("定义一个普通的对象类型")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type MyObject = Record<string, string>;\n等价于\ntype MyObject = {\n  [x: string]: string;\n}\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("搭配联合类型用法")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Test = 'name' | 'age' | 'sex';\ntype TestOne = Record<Test, string>; \n等价于\ntype TestOne = {\n  name: string;\n  age: string;\n  sex: string;\n}\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("射对象,让对象的每个属性都是一个拥有特定键值对的类型")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Test {\n  name: string;\n  age: string;\n  sex: string;\n}\ntype Person = Record<string, Test>;\n\n等价于\ntype Person = {\n    [x: string]: Test;\n}\n")])])]),n("ul",[n("li",[e._v("Record的内部定义，接收两个泛型参数")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Record<K extends string|number|symbol, T> = {\n  [P in K] : T;\n}\n")])])]),n("h2",{attrs:{id:"partial"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#partial"}},[e._v("#")]),e._v(" Partial")]),e._v(" "),n("p",[e._v("ts中就是让一个定义中的所有属性都变成可选参数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  name: string\n  age: number\n}\nconst studentOne:Person = {\n  name: 'tom'\n}\n")])])]),n("p",[e._v("上述例子studentOne如果只有nam属性，ts会提醒缺失age属性, 这个时候可以使用Partial")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const studentOne:Partial<Person> = {\n  name: 'tom'\n}\n")])])]),n("p",[e._v("内部实现")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n")])])]),n("h2",{attrs:{id:"required"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#required"}},[e._v("#")]),e._v(" Required")]),e._v(" "),n("p",[e._v("和Partial刚好相反，将一个定义中的属性全部变成必选参数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  name?: string\n  age: number\n}\nconst studentOne:Person = {\n  age: 333\n}\n")])])]),n("p",[e._v("上述例子中定义了name为可选属性，所以studentOne中即使定义了age也是可以通过的")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  name?: string\n  age: number\n}\nconst studentOne:Required<Person> = {\n  age: 333\n}\n")])])]),n("p",[e._v("但是这个时候就会提示缺失name属性了")]),e._v(" "),n("ul",[n("li",[e._v("实现原理")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Required<T> = {\n  [P in keyof T]?: T[P];\n}\n")])])]),n("h2",{attrs:{id:"pick"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pick"}},[e._v("#")]),e._v(" Pick")]),e._v(" "),n("p",[e._v("可以选择一个原来的接口中一部分的属性定义")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  name?: string;\n  sex:string;\n  age: number;\n}\ntype newPerson = Pick<Person, 'name'|'age'>\n\n等价于\ntype newPerson = {\n  name: string;\n  age: number;\n}\n")])])]),n("ul",[n("li",[e._v("内部实现原理")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Pick<T, K extends keyof T> = {\n  [P in K]: T[P]\n}\n\n第一个泛型 T 便是 interface 或者 type 定义\n第二个就是第一个定义中的属性， extends就代表继承\nK extends keyof T 等同于 k extends ‘name’ | ‘age’,意思就是k只能是age或者name\n")])])]),n("h2",{attrs:{id:"readonly"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#readonly"}},[e._v("#")]),e._v(" Readonly")]),e._v(" "),n("p",[e._v("让一个定义中的所有属性都变成只读参数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  name?: string;\n  sex:string;\n  age: number;\n}\nlet newPerson:Readonly<Person>= {\n  name: 'eee',\n  sex: 'eee',\n  age: 2\n} \nnewPerson.age = 4444; // 这句话会报错\n")])])]),n("p",[e._v("上面的写法等价于")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  readonly name?: string;\n  readonly sex:string;\n  readonly age: number;\n}\nlet newPerson:Readonly<Person>= {\n  name: 'eee',\n  sex: 'eee',\n  age: 2\n} \n")])])]),n("ul",[n("li",[e._v("内部实现原理")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n}\n")])])]),n("h2",{attrs:{id:"exclude"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#exclude"}},[e._v("#")]),e._v(" Exclude")]),e._v(" "),n("p",[e._v("ts中可以排除 "),n("strong",[e._v("联合类型")]),e._v(" 中一部分的内容")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type StuType = 'age' | 'sex' | 'name';\ntype newPersonType = Exclude<Person, 'age'>;\n\n等价于 \ntype newPersonType = 'sex' | 'name';\n")])])]),n("ul",[n("li",[e._v("Exclude的原理")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Exclude<T, U> = T extends U ? never : T\n")])])]),n("p",[e._v("我们这里用 StuType 也就是 ‘name’ | ‘age’ | sex 去代表 T\n用 age 属性去代表第二个泛型 U\nT extends U 就判断是否’name’ | ‘age’ | 'sex' 有 name， 有name就返回never,就代表将其排除")]),e._v(" "),n("h2",{attrs:{id:"omit-省略的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#omit-省略的"}},[e._v("#")]),e._v(" Omit (省略的)")]),e._v(" "),n("p",[e._v("将 "),n("strong",[e._v("接口或者类型")]),e._v(" 的键值对删除一部分")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("interface Person {\n  readonly name?: string;\n  readonly sex:string;\n  readonly age: number;\n}\ntype newPerson = Omit<Person, 'age'>;\n等价于\ntype newPerson = {\n  name: string,\n  sex: string,\n} \n")])])]),n("ul",[n("li",[e._v("Omit实现原理")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("type Omit<T, K extends string | number | symbol> = {\n  [P in Exclude<keyof T, K>]: T[P]\n}\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);