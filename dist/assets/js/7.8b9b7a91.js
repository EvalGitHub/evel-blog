(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{410:function(t,r,e){t.exports=e.p+"assets/img/http_link_count.f94e2326.png"},411:function(t,r,e){t.exports=e.p+"assets/img/stream_data.8c5495ee.png"},412:function(t,r,e){t.exports=e.p+"assets/img/http2_frame_constructor.4b5dd7bb.png"},503:function(t,r,e){"use strict";e.r(r);var a=e(28),n=Object(a.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http2新功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2新功能"}},[t._v("#")]),t._v(" http2新功能")]),t._v(" "),a("p",[t._v("http2是一个二进制协议，http1.1是文本协议")]),t._v(" "),a("h3",{attrs:{id:"http2多路复用-multiplexing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2多路复用-multiplexing"}},[t._v("#")]),t._v(" http2多路复用 (Multiplexing)")]),t._v(" "),a("p",[t._v("多路复用允许"),a("strong",[t._v("同时")]),t._v("通过单一的 HTTP/2 连接"),a("strong",[t._v("发起多重")]),t._v("的请求-响应消息。\n在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞；并且一个http链接同一时间只支持单个请求；即使是管道化在服务器响应的时候也是串行的，并未做到真正意义的并行。")]),t._v(" "),a("p",[t._v("每个 Frame Header 都有一个 Stream ID 就是被用于实现该特性。"),a("strong",[t._v("每次请求/响应使用不同的 Stream ID")]),t._v("。")]),t._v(" "),a("p",[t._v("HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，并行地在同一个 TCP 连接上双向交换消息。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(410),alt:"avatar"}})]),t._v(" "),a("h3",{attrs:{id:"二进制分帧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制分帧"}},[t._v("#")]),t._v(" 二进制分帧")]),t._v(" "),a("p",[t._v("在应用层和传输层之间增加一个"),a("strong",[t._v("二进制分帧层")]),t._v("，在二进制分帧层中所有的传输信息都会被分割为更小的帧，并采用二进制格式编码，每个帧都有数据流的唯一标识，这样在数据帧到达目的主机时候，再按照数据流标识进行重组。")]),t._v(" "),a("p",[t._v("每个帧的格式基本如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:e(411),alt:"avatar"}})]),t._v(" "),a("ul",[a("li",[t._v("Length：表示Frame payload的长度")]),t._v(" "),a("li",[t._v("type：用于区分这个帧属于HTTP Header还是HTTP body")]),t._v(" "),a("li",[t._v("stream_identifier：当客户端和服务端建立TCP链接时，就会先发送一个 Stream ID = 0的流，用来做些初始化工作。之后客户端和服务端从 1 开始发送请求/响应，\n用于表示每个数据帧属于那个流")])]),t._v(" "),a("p",[t._v("Frame 由 Frame Header 和 Frame Payload 两部分组成。不论是原来的 HTTP Header 还是 HTTP Body，在 HTTP/2 中，都将这些数据存储到 Frame Payload，组成一个个 Frame，再发送响应/请求。通过 Frame Header 中的 Type 区分这个 Frame 的类型。由此可见语义并没有太大变化。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(412),alt:"avatar"}})]),t._v(" "),a("h3",{attrs:{id:"优先级和依赖性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先级和依赖性"}},[t._v("#")]),t._v(" 优先级和依赖性")]),t._v(" "),a("p",[t._v("每个流都包含一个优先级（也就是“权重”），它被用来告诉对端哪个流更重要。\n当资源有限的时候，服务器会根据优先级来选择应该先发送哪些流。\n借助于PRIORITY帧，客户端同样可以告知服务器当前的流依赖于其他哪个流。该功能让客户端能建立一个优先级“树”，所有“子流”会依赖于“父流”的传输完成情况。")]),t._v(" "),a("h3",{attrs:{id:"首部压缩-header-compression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#首部压缩-header-compression"}},[t._v("#")]),t._v(" 首部压缩（Header Compression）")]),t._v(" "),a("p",[t._v("随着页面资源的个数增加，cookies和请求的大小都会增加，有必要对其进行压缩。")]),t._v(" "),a("p",[t._v("http1.1不支持http首部压缩，为此SPDY和HTTP/2应运而生，而HTTP2使用的是"),a("a",{attrs:{href:"http://http2.github.io/http2-spec/compression.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HPACK"),a("OutboundLink")],1),t._v("算法,\nSPDY使用的是"),a("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/DEFLATE",target:"_blank",rel:"noopener noreferrer"}},[t._v("DEFLATE"),a("OutboundLink")],1),t._v("算法")]),t._v(" "),a("p",[t._v("SPDY是谷歌公司开源的一个对HTTP1.1优化的项目，http2摄取了其很多优点。（首部压缩算法不同）")]),t._v(" "),a("p",[a("strong",[t._v("HPACK压缩算法的原理")])]),t._v(" "),a("p",[t._v("static table：")]),t._v(" "),a("p",[t._v("使用一份索引表来带定义"),a("strong",[t._v("常用的HTTP Header")]),t._v("，请求的时候只需要发送在表里的索引位置即可。\n完整的索引表可参考"),a("a",{attrs:{href:"http://http2.github.io/http2-spec/compression.html#rfc.section.A",target:"_blank",rel:"noopener noreferrer"}},[t._v("static table"),a("OutboundLink")],1),t._v("；")]),t._v(" "),a("p",[t._v("Dynamic Table：")]),t._v(" "),a("p",[t._v("每次请求还可以在表的末尾动态追加新的 HTTP Header 缓存。动态部分称之为 Dynamic Table。")]),t._v(" "),a("p",[t._v("对于相同的头部字段，第二次请求则不会发送，只会发送差异数据，减少冗余数据节省开销。")]),t._v(" "),a("p",[t._v("HPACK不仅仅是通过索引值来降低请求头部数据量，同时还会将字符串进行"),a("strong",[t._v("霍夫曼编码")]),t._v("来压缩字符串大小")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/75048255",target:"_blank",rel:"noopener noreferrer"}},[t._v("哈夫曼编码的理解(Huffman Coding)"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://www.cnblogs.com/daoluanxiaozi/archive/2011/12/26/2302464.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("哈夫曼压缩算法"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"服务端推送-缓存推送"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端推送-缓存推送"}},[t._v("#")]),t._v(" 服务端推送（缓存推送）")]),t._v(" "),a("p",[t._v("当一个客户端请求资源X时候，服务器知道他很有可能也需要资源Z，于是服务器可以在客户端请求之前主动将资源Z推送给客户端，客户端将其放进缓存以备将来之需。")]),t._v(" "),a("p",[t._v("当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。\n意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，便会准备接收服务端要推送的流")]),t._v(" "),a("p",[t._v("前提是服务器推送需要客户端显式的允许服务器提供该功能。如果服务器推送的资源已经被浏览器缓存过，则浏览器可以通过发送RES_STREAM帧来拒收")]),t._v(" "),a("h3",{attrs:{id:"流量控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流量控制"}},[t._v("#")]),t._v(" 流量控制")]),t._v(" "),a("p",[t._v("每个http2流都拥有自己的"),a("strong",[t._v("公示的流量窗口，它可以限制另一端发送数据")]),t._v("。\n对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。\n而只有数据帧会受到流量控制。")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://io.upyun.com/2015/05/13/http2/",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP/2 新特性浅析"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.zhihu.com/question/34074946",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP/2 相比 1.0 有哪些重大改进？"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://ye11ow.gitbooks.io/http2-explained/content/part3.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("http2 gitbook"),a("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=n.exports}}]);