(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{462:function(e,r,t){e.exports=t.p+"assets/img/vite.670a299c.svg"},608:function(e,r,t){"use strict";t.r(r);var n=t(28),a=Object(n.a)({},(function(){var e=this,r=e.$createElement,n=e._self._c||r;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"vite剖析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vite剖析"}},[e._v("#")]),e._v(" vite剖析")]),e._v(" "),n("h2",{attrs:{id:"vite执行流程梳理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vite执行流程梳理"}},[e._v("#")]),e._v(" vite执行流程梳理")]),e._v(" "),n("p",[n("img",{attrs:{src:t(462),alt:"avatar"}})]),e._v(" "),n("h2",{attrs:{id:"构建本地服务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构建本地服务"}},[e._v("#")]),e._v(" 构建本地服务")]),e._v(" "),n("p",[e._v("使用node的http模块创建一个静态服务，然后监听")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let httpServer = require('http').createServer(app).listen(port);\n")])])]),n("ul",[n("li",[e._v("在vite中如果首次的端口被占用会，会自动将端口加1，启动；实现方式就是监听错误日志，如果被占用就自动加1")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const onError = (e: Error & { code?: string }) => {\n    if (e.code === 'EADDRINUSE') {\n    if (options.strictPort) {\n        httpServer.removeListener('error', onError)\n        reject(new Error(`Port ${port} is already in use`))\n    } else {\n        info(`Port ${port} is in use, trying another one...`)\n        httpServer.listen(++port) // 将端口自动加一\n    }\n    } else {\n    httpServer.removeListener('error', onError)\n    reject(e)\n    }\n}\n// 监听启动的错误\nhttpServer.on('error', onError); \n")])])]),n("ul",[n("li",[e._v("vite会将localhost以及网络ip端口都会打印出来")])]),e._v(" "),n("p",[e._v('实现方式：使用node的 "os"模块')]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const interfaces = os__default.networkInterfaces();\n// console.log('interfaces', interfaces);\nObject.keys(interfaces).forEach(\n    (key) => (interfaces[key] || [])\n    .filter((details) => details.family === 'IPv4')\n    .map((detail) => {\n    return {\n        type: detail.address.includes('127.0.0.1')\n            ? 'Local:   '\n            : 'Network: ',\n        host: detail.address.replace('127.0.0.1', hostname)\n    };\n})\n    .forEach(({ type, host }) => {\n    const url = `${protocol}://${host}:${source.bold(port)}${base}`;\n    info(`  > ${type} ${source.cyan(url)}`);\n}));\n")])])]),n("h2",{attrs:{id:"监听文件的改变-热更新"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#监听文件的改变-热更新"}},[e._v("#")]),e._v(" 监听文件的改变&热更新")]),e._v(" "),n("ul",[n("li",[e._v("是如何监听到文件的改变的")])]),e._v(" "),n("p",[e._v("使用开源库 "),n("a",{attrs:{href:"https://www.npmjs.com/package/chokidar",target:"_blank",rel:"noopener noreferrer"}},[e._v("chokidar"),n("OutboundLink")],1)]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 监听整个目录的改变\nconst watcher = chokidar.watch(path.resolve(root), {\n    ignored: ['**/node_modules/**', '**/.git/**', ...ignored],\n    ignoreInitial: true,\n    ignorePermissionErrors: true,\n    disableGlobbing: true,\n    ...watchOptions\n}) as FSWatcher;\n\n// 文件的改变\nwatcher.on('change', async (file) => {\n    file = normalizePath(file)\n    // invalidate module graph cache on file change\n    moduleGraph.onFileChange(file)\n    if (serverConfig.hmr !== false) {\n        try {\n            await handleHMRUpdate(file, server)\n        } catch (err) {\n            ws.send({\n                type: 'error',\n                err: prepareError(err)\n            })\n        }\n    }\n})\n\n// 文件的添加\nwatcher.on('add', (file) => {\n    handleFileAddUnlink(normalizePath(file), server)\n})\n\n// 文件的删除\nwatcher.on('unlink', (file) => {\n    handleFileAddUnlink(normalizePath(file), server, true)\n})\n")])])]),n("h2",{attrs:{id:"文件改变是怎么实现浏览器实时更新的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件改变是怎么实现浏览器实时更新的"}},[e._v("#")]),e._v(" 文件改变是怎么实现浏览器实时更新的")]),e._v(" "),n("p",[e._v("通过websocket进行实时通信, 发送请求，请求的url中包含地址，文件名，通过解析相关信息，拼接成完整的文件地址，读取文件内容，返回到对应请求。")]),e._v(" "),n("ul",[n("li",[e._v("浏览器怎么发的请求？")])]),e._v(" "),n("p",[e._v("使用import来对文件进行请求，因为import本身就是一个promise, 发送请求，然后返回读取的文件内容")])])}),[],!1,null,null,null);r.default=a.exports}}]);