(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{531:function(t,e,a){"use strict";a.r(e);var r=a(28),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react中组件相互通信的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react中组件相互通信的方式"}},[t._v("#")]),t._v(" react中组件相互通信的方式")]),t._v(" "),a("p",[t._v("项目开发中组件之间的相互传递属性是十分常见的，尤其在react这种单向数据流框架中。")]),t._v(" "),a("h2",{attrs:{id:"父-子组件传递信息-props的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父-子组件传递信息-props的使用"}},[t._v("#")]),t._v(" 父，子组件传递信息（props的使用）")]),t._v(" "),a("ul",[a("li",[t._v("最常用的方式就是通过props来进行属性的传递")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" <DataList\n  pageSize={this.state.pageSize}\n  initalCurrentPage={this.state.initalCurrentPage}\n  dataList={this.state.dataList} \n  getWorksInfo={this.getWorksInfo.bind(this)}/>\n")])])]),a("p",[t._v("我们可以看到在上面的例子中我们通过props(pageSize,initalCurrentPage,dataList)向组件DataList传递了三个属性值，在DataList中我们只需要通过this.props[变量名]即可获取父组件传递的值，这样就完成了"),a("strong",[t._v("父组件向子组件")]),t._v("的一个信息传递。")]),t._v(" "),a("ul",[a("li",[t._v("那么在父组件中如何调用子组件的方法了？")])]),t._v(" "),a("p",[t._v("通过ref获取到子组件实例，然后可以使用这个实例对子组件做很多是（函数的调用，state的更改等等...）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class ParentComponent {\n  private SearchTab: SearchTab;\n  ...\n  ...\n\n  updateDateList () {\n    this.SearchTab.setState({\n      count: 0;\n    });\n    this.SearchTab.filterData();\n  };\n\n  render () {\n    return (\n      <>\n        <DataList\n          ref={r => this.SearchTab = r} \n          pageSize={this.state.pageSize}\n          initalCurrentPage={this.state.initalCurrentPage}\n          getWorksInfo={this.getWorksInfo.bind(this)}\n          />\n      </>\n    )\n  }\n}\n")])])]),a("blockquote",[a("p",[t._v("也可以通过React.createRef()方法实现，原理相同")])]),t._v(" "),a("ul",[a("li",[t._v("如何实现子组件向父组件传递信息了？")])]),t._v(" "),a("p",[t._v("最常用的方式就是通过在子组件中回调父组件传递的方法；在上面例子中我们可以看到"),a("strong",[t._v("getWorksInfo")]),t._v("这个属性是一个函数（绑定了父组件的getWorksInfo方法），那么在DataList中就可以使用**this.props.getWorksInfo(prams1,....)**来调用父组件中的方法了（可以传递参数更新父组件的state,还可以在这个回调中调用父组件其他方法）这样就简单完成了从子组件向父组件的之间的通信。")]),t._v(" "),a("h2",{attrs:{id:"跨级组件之间的相互通信-context-react-forwardref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨级组件之间的相互通信-context-react-forwardref"}},[t._v("#")]),t._v(" 跨级组件之间的相互通信（context，React.forwardRef）")]),t._v(" "),a("p",[t._v("在项目开发中经常会用到跨级组件的之间的相互通信")]),t._v(" "),a("p",[t._v("我们可以通过context进行消息传递，关于context的使用，参考示例代码如下："),a("a",{attrs:{href:"https://github.com/EvalGitHub/webpack_reactJS/blob/master/src/index.tsx",target:"_blank",rel:"noopener noreferrer"}},[t._v("React.createContext"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("关于"),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-api.html#reactforwardref",target:"_blank",rel:"noopener noreferrer"}},[t._v("React.forwardRef"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"组件之间通信的其他方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件之间通信的其他方式"}},[t._v("#")]),t._v(" 组件之间通信的其他方式")]),t._v(" "),a("p",[t._v("以上的几种方式都是react官方明确给出，组件之间的相互通信涉及两种：状态属性的传递，触发组件之间的方法；但是对于属性的传递我们可以跳出react还有很多思路")]),t._v(" "),a("ol",[a("li",[t._v("借助浏览器缓存（localStorage，sessionStorage）")]),t._v(" "),a("li",[t._v("redux等第三方状态管理工具库")])]),t._v(" "),a("h2",{attrs:{id:"兄弟组件之间的相互通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#兄弟组件之间的相互通信"}},[t._v("#")]),t._v(" 兄弟组件之间的相互通信")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("通过props与ref的组合形式")]),t._v(" "),a("p",[a("strong",[t._v("具体思路：")]),t._v(" 父组件将方法fn（fn中通过ref获取组件B的实例）通过props传递给组件A，组件A就可以通过回调fn间接与组件B进行通信了。")])]),t._v(" "),a("li",[a("p",[t._v("通过redux")]),t._v(" "),a("p",[t._v("详细使用方式参照redux的使用方式。")])]),t._v(" "),a("li",[a("p",[t._v("通过自定义事件的方式(此方法不仅仅适用于兄弟组件之间的通信)（借助"),a("a",{attrs:{href:"https://www.npmjs.com/package/events",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node.js Events"),a("OutboundLink")],1),t._v("模块的浏览器版实现）")])])]),t._v(" "),a("p",[a("strong",[t._v("具体实现方式：")])]),t._v(" "),a("ol",[a("li",[t._v("首先需要在建立一个模块")])]),t._v(" "),a("p",[t._v("create_event.tsx")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import { EventEmitter } from 'events';\nexport const emitter = new EventEmitter();\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("使用这个模块emitter去emit定义一个消息'changeMessage'，以及传递参数")])]),t._v(" "),a("p",[t._v("detail.tsx")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("emitter.emit('changeMessage', '改变msg');\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("订阅这个消息")])]),t._v(" "),a("p",[t._v("react_create_ele.tsx")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("createMsg () {\n  this.eventEmitter = emitter.on('changeMessage', (message) => {\n    this.setState({\n      message,\n    });\n  }).removeListener('updateUserInfoSucc', () => {\n    // 每一次监听之后就移除，避免重复监听\n    console.log('移除');\n  });;\n};\ncomponentWillUnmount() {\n  // emitter.removeAllListeners();\n  emitter.removeListener(this.eventEmitter, () => {});\n};\ncomponentDidMount () {\n  this.createMsg();\n};\n")])])]),a("p",[t._v("具体实现代码参考："),a("a",{attrs:{href:"https://github.com/EvalGitHub/webpack_reactJS/tree/master/src/components/event_trans_info",target:"_blank",rel:"noopener noreferrer"}},[t._v("event_trans_info"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("参考："),a("a",{attrs:{href:"https://segmentfault.com/a/1190000012361461?utm_source=tag-newest#articleHeader6",target:"_blank",rel:"noopener noreferrer"}},[t._v("React中组件通信的几种方式"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);