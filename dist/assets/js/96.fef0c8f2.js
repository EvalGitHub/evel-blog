(window.webpackJsonp=window.webpackJsonp||[]).push([[96],{555:function(t,n,e){"use strict";e.r(n);var a=e(28),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"实现楼层效果-html页面锚点跳转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现楼层效果-html页面锚点跳转"}},[t._v("#")]),t._v(" 实现楼层效果(html页面锚点跳转)")]),t._v(" "),e("h2",{attrs:{id:"css-html锚点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-html锚点"}},[t._v("#")]),t._v(" css/html锚点")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<a href="#works"></a>\n\n<section id="works">\n  .....\n  ....\n  .....\n</section>\n')])])]),e("blockquote",[e("p",[t._v("缺点：是点击锚点之后，浏览器的URL会发生变化，如果刷新或返回该页面可能会出现问题。")])]),t._v(" "),e("h2",{attrs:{id:"通过window-location-hash-top-或者window-location-href-top-跳转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过window-location-hash-top-或者window-location-href-top-跳转"}},[t._v("#")]),t._v(' 通过window.location.hash="#top"或者window.location.href="#top"跳转')]),t._v(" "),e("blockquote",[e("p",[t._v("但地址也会发生变化。")])]),t._v(" "),e("h2",{attrs:{id:"通过label标签-与-input标签"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过label标签-与-input标签"}},[t._v("#")]),t._v(" 通过label标签 与 input标签")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!Doctype html>\n<html>\n  <head>\n    <style>\n      .tab {\n        height: 30px;\n      }\n      .label {\n        width: 100px;\n        margin-right: -1px;\n        border: 1px solid #ccc; border-bottom: 0;\n        padding-top: 5px; padding-bottom: 5px;\n        background-color: #eee;\n        text-align: center;\n      }\n      .box { \n        height: 200px; \n        border: 1px solid #ccc; \n        scroll-behavior: smooth;  // \b滚动优化\n        overflow: hidden; \n      }\n      .content { \n        height: 100%; \n        padding: 0 20px; \n        position: relative; \n        overflow: hidden;\n      }\n      .box input { \n        position: absolute; top:0; \n        height: 100%; width: 1px;\n        border:0; padding: 0; margin: 0;\n        /* clip: rect(0 0 0 0); */\n      }\n    </style>\n  </head>\n  <body>\n    <div class="tab">\n      <label class="label" for="tab1">选项卡1</label>\n      <label class="label" for="tab2">选项卡2</label>\n      <label class="label" for="tab3">选项卡3</label>\n  </div>\n  <div class="box">\n      <div class="content"><input id="tab1">\n          <p>我是选项卡1对应的content</p>\n          <img src="./pic.jpg" />\n      </div>\n      <div class="content"><input id="tab2">\n          <p>我是选项卡2对应的content</p>\n          <img src="./pic.jpg" />\n      </div>\n      <div class="content"><input id="tab3">\n          <p>我是选项卡3对应的content</p>\n          <img src="./pic.jpg" />\n      </div>\n  </div>\n  </body>\n</html>\n')])])]),e("h2",{attrs:{id:"scrollintoview将目标元素滚动到可视区域置顶位置-顶部"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#scrollintoview将目标元素滚动到可视区域置顶位置-顶部"}},[t._v("#")]),t._v(" scrollIntoView将目标元素滚动到可视区域置顶位置（顶部..）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('scrollIntoView (eleId:any) {\n    document.getElementById(eleId).scrollIntoView({\n      block: "start",\n      behavior: "smooth"\n    })\n};\n\n<li onClick={this.scrollIntoView.bind(this, \'productIntroduce\')}>\n   <a>{MainText.productIntroduce}</a>\n </li>  \n')])])]),e("blockquote",[e("p",[t._v("1）URL不会变，同时能够响应相应的scroll事件。\n2）可以设置动画效果")])]),t._v(" "),e("h2",{attrs:{id:"常见需求监听屏幕滚动-出现置顶按钮"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见需求监听屏幕滚动-出现置顶按钮"}},[t._v("#")]),t._v(" 常见需求监听屏幕滚动，出现置顶按钮")]),t._v(" "),e("p",[e("strong",[t._v("分析：")]),t._v("我们需要监听某一个目标元素的滚动距离，滚动距离 >= 这个屏幕的高度的时候，就出现这个按钮")]),t._v(" "),e("p",[e("strong",[t._v("目标元素的滚动距离：")]),t._v(" 可以通过元素的scrollTop获取")]),t._v(" "),e("p",[e("strong",[t._v("屏幕的高度：")]),t._v("可以通过document.body.clientHeight, 通过 CSS height + CSS padding - 水平滚动条高度 (如果存在)来计算。如果我们把目标元素的高度设置为boby的高度相同的情况下，可以直接通过\ndocument.getElementById('targetEleID').clientHeight获取可视区域的高度")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 监听屏幕滚动\npublic watchScroll (e:any) {\n  if (document.getElementsByClassName('pc_work_detail_wrapper')[0].scrollTop >= document.getElementsByClassName('pc_work_detail_wrapper')[0].clientHeight - 200) {\n      !this.state.showUpArrow && (() => { // !this.state.showUpArrow优化，避免多次执行\n        this.setState({ showUpArrow: true });\n      })()\n    } else {\n      this.state.showUpArrow && (() => {\n        this.setState({ showUpArrow: false });\n      })()\n    }\n  };\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);