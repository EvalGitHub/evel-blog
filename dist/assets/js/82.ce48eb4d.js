(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{535:function(e,t,n){"use strict";n.r(t);var a=n(28),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"react函数编程hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react函数编程hook"}},[e._v("#")]),e._v(" react函数编程hook")]),e._v(" "),n("p",[n("strong",[e._v("定义")])]),e._v(" "),n("blockquote",[n("p",[e._v("Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性")])]),e._v(" "),n("p",[n("strong",[e._v("解决问题：")])]),e._v(" "),n("ul",[n("li",[e._v("class组件逻辑难复用（高阶组件，render props） ---\x3e 自定义hook实现逻辑的复用，因为组件和 Hook 都是函数，所以操作起来很方便。")]),e._v(" "),n("li",[e._v("class组件代码趋于复杂不易被理解 ---\x3e 使用function")]),e._v(" "),n("li",[e._v("class组件的生命周期中往往会注入许多逻辑代码,甚至是滥用 ---\x3e 去掉构造函数、生命周期提升性能，useEffect中可以返回回调函数清除副作用，而不需要在多个生命周期中写入处理代码")]),e._v(" "),n("li",[e._v("class组件this的必须邦定， hook中不需要绑定this")])]),e._v(" "),n("p",[e._v("至于性能方面的提升还有带商榷。")]),e._v(" "),n("p",[n("strong",[e._v("好处")])]),e._v(" "),n("blockquote",[n("p",[e._v("从此可以很流畅的编写无状态组件，减少代码量")])]),e._v(" "),n("p",[n("strong",[e._v("注意")])]),e._v(" "),n("ul",[n("li",[n("p",[e._v("Hook不能在class组件中使用")])]),e._v(" "),n("li",[n("p",[e._v("不要在循环，条件或者嵌套函数中调用hook，确保总是在React最顶层调用")]),e._v(" "),n("p",[e._v("列举一种经常的错误：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  // 🔴 在条件语句中使用 Hook 违反第一条规则\n  if (name !== '') {\n    useEffect(function persistForm() {\n      localStorage.setItem('formData', name);\n    });\n  }\n")])])]),n("blockquote",[n("p",[e._v("确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。")])])])]),e._v(" "),n("p",[n("strong",[e._v("因为react hook的内部实现是方式是使用链表来记录每个hook的执行顺序的；如果在条件语句等非react组件顶层声明的hok会导致记录顺序出错。")])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.jianshu.com/p/b9ac8fa849f1",target:"_blank",rel:"noopener noreferrer"}},[e._v("react hook原理"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"usestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[e._v("#")]),e._v(" useState")]),e._v(" "),n("blockquote",[n("p",[e._v("import React, { useState } from 'react';")])]),e._v(" "),n("ul",[n("li",[e._v("useState会返回一对值：当前状态、更新状态的函数；类似 class 组件的 this.setState，但是它不会把新的 state 和旧的 state 进行合并")]),e._v(" "),n("li",[e._v("useState 唯一的参数就是初始state")]),e._v(" "),n("li",[e._v("使用Object.is进行判断，如果传入的值相等就不会更新，这点相对于class组件来时是做了优化处理，不需要手动去使用\nshouldComponentUpdate去判断。")])]),e._v(" "),n("p",[e._v("函数组件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import * as React from 'react';\nexport function Example () {\n  const [count, setCount] = React.useState(0);\n  const [obj, setObj] = React.useState({\n    name: '测试对象',\n    age: 12\n  })\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <p>You age {obj.age} </p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n      <button onClick={() => setObj({...obj, age: obj.age+1})}>\n        Add you age\n      </button>\n    </div>\n  );\n}\n")])])]),n("blockquote",[n("p",[e._v("如果我们想要在 state 中存储两个不同的变量，只需调用 useState() 两次即可。")])]),e._v(" "),n("p",[e._v("传入函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("setState(prevState => { // 可以拿到上一次的 state 值\n  // 也可以使用 Object.assign\n  return {...prevState, ...updatedValues};\n});\n")])])]),n("p",[n("strong",[e._v("惰性的初始化")])]),e._v(" "),n("blockquote",[n("p",[e._v("该initialState参数是在初始渲染中使用的状态。在后续渲染中，将忽略它。如果初始状态是昂贵的计算结果，则可以提供一个函数，该函数仅在初始渲染器上执行：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const [state, setState] = useState(() => {\n  const initialState = someExpensiveComputation(props);\n  return initialState;\n});\n")])])]),n("p",[n("strong",[e._v("源码分析")])]),e._v(" "),n("p",[e._v("常规用法：const [count, setCount] = React.useState(0)\n返回一个函数，第一个参数是一个state值，第二个参数是修改state的函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Object.assing(React,  {\n  useState(initVal:any) {\n   function setVal(val:any) {\n     initVal = val;\n   }\n   return [initVal, setVal] \n  }\n})\n")])])]),n("h2",{attrs:{id:"useeffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[e._v("#")]),e._v(" useEffect")]),e._v(" "),n("p",[n("strong",[e._v("副作用/作用的概念")])]),e._v(" "),n("blockquote",[n("p",[e._v("数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”；可分为需要清除的副作用，和不需要清除的副作用。")])]),e._v(" "),n("p",[n("strong",[e._v("useEffect的作用")])]),e._v(" "),n("blockquote",[n("p",[e._v("useEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途")])]),e._v(" "),n("p",[n("strong",[e._v("使用useEffect：不需要清除的副作用")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect } from 'react';\nfunction Example() {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n")])])]),n("blockquote",[n("p",[e._v("默认在组件挂载完之后，和组件更新之后都会执行")])]),e._v(" "),n("p",[n("strong",[e._v("使用useEffect：需要清除的副作用")])]),e._v(" "),n("ul",[n("li",[e._v("只需要在useEffect中返回一个函数，React将会在"),n("strong",[e._v("组件卸载时")]),e._v("执行清除操作")]),e._v(" "),n("li",[e._v("每个 effect 都可以返回一个清除函数,可选的清除机制")]),e._v(" "),n("li",[e._v("会在调用一个新的effect之前对前一个effect进行清理，对于需要清理的副作用(定时器，监听器)我们需要定义这个函数，\n并且为防止内存泄漏，清除函数会在组件卸载前执行。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useState, useEffect } from 'react';\nfunction FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n  // ...\n}\n")])])]),n("p",[e._v("对于上面的例子我么会发现，每一次的组件更新都会执行"),n("strong",[e._v("document.title = `You clicked ${count} times")]),e._v("，问题是有时候即使我们没有更新count但还是会执行这句话，就是没有必要的性能浪费。")]),e._v(" "),n("ul",[n("li",[e._v("class组件中可以做如下优化")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("componentDidUpdate (preProps, preState) {\n  if(preState.count !== this.state.count) {\n    document.title = `You clicked ${count} times\n  }\n}\n\n")])])]),n("ul",[n("li",[e._v("在useEffect中")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("useEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]); // 仅在 count 更改时更新\n")])])]),n("blockquote",[n("p",[e._v("如果数组中有多个元素，即使只有一个元素发生变化，React 也会执行 effect。")])]),e._v(" "),n("h3",{attrs:{id:"关于第二个参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关于第二个参数"}},[e._v("#")]),e._v(" 关于第二个参数")]),e._v(" "),n("p",[e._v("常见的一个问题，如果第二个参数省略了在useEffect中执行了相关的异步操作并且修改了某个状态，会发现一直循环的执行下去，\n这个时候就可以传入了一个空数组（[]）去解决这个问题，传入一个空数组的作用就相当于是状态组件的componentDidMounted中\n执行一样，只会在组件mount之后，ummount之前执行。")]),e._v(" "),n("blockquote",[n("p",[e._v("函数组件初始化，以及状态更新的时候(如果没有提供第二个参数)，都会执行useEffect。")])]),e._v(" "),n("p",[n("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/65773322",target:"_blank",rel:"noopener noreferrer"}},[e._v("useEffect使用指南"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("strong",[e._v("源码分析")])]),e._v(" "),n("p",[e._v("useEffect接受两个参数，第一个回调函数，第二个参数是一个数组")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Object.assign(React, {\n  let _tmp = null;\n  useEffect(callback, depArr:any[]) {\n    if (!_tmp) {\n      _tmp = depArr.slice();\n    }\n    let _shouldUpdate = depArr.length === 0 ? true : depArr.every((item:any, index:number) => _tmp[index]) ? false : true;\n    if (_shouldUpdate) {\n      callback();\n      _tmp = depArr.slice();\n    }\n  }\n})\n")])])]),n("p",[n("strong",[e._v("进一步拓展")])]),e._v(" "),n("blockquote",[n("p",[e._v("在react hook的使用限制中明确指出，reactHook必须在函数组件的最顶层建立，不能在条件语句循环语句，以及自定义的函数中建立的原因是什么？")])]),e._v(" "),n("p",[e._v("首先我们可以看到在定义React.useState、React.useEffect的时候我们可以建立多个，在使用的时候，并不会出现混淆，原因就是hook的源码中使用数组来存储着他们的定义顺序（多以禁忌在条件语句中定义）。")]),e._v(" "),n("p",[e._v("进一步优化上面的源码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const React = (function(){\n  let hooks = [];\n  let currentIndex = 0;\n  return Object.design(React, {\n    useState(initStateVal) {\n      hooks[currentIndex] = initStateVal;\n      function setState(val) {\n        hooks[currentIndex] = val;\n      }\n      return [hooks[currentIndex++], setState]\n    },\n   \n    useEffect(callback, depArr) {\n      hooks[currntIndex] = depArr.slice();\n      let shouleUpdate = depArr.length === 0? hooks[currntIndex].every((item:any, index:number) => hooks[currntIndex][index] === item) ? false : true;\n      if (shouleUpdate) {\n        callback();\n        hooks[currntIndex++] = depArr;\n      }\n    }\n  })\n})()\n\n")])])]),n("h2",{attrs:{id:"usecontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[e._v("#")]),e._v(" useContext")]),e._v(" "),n("p",[e._v("接受一个context对象并返回该context的当前值；读取 context 的值以及订阅 context的变化")]),e._v(" "),n("ul",[n("li",[e._v("useContext 的参数必须是 context 对象本身")])]),e._v(" "),n("p",[n("strong",[e._v("在父组件中创建一个context")])]),e._v(" "),n("ul",[n("li",[e._v("createContext（）创建一个上下文")]),e._v(" "),n("li",[e._v("Provider：用于生产共享数据的地方；value：用于放置共享的数据")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// index.tsx\n// 创建一个context\nexport const NameContext = React.createContext({\n  name: \"默认名称\",\n  changeName: () => {}\n});\nclass App extends React.Component<initProps, initState> {\n  constructor (props:any) {\n    super (props);  \n    this.state = {\n      name: '我不是默认值'\n    }\n  }\n  changeName = () => {\n    this.setState({\n      name: '我是改变的值'\n    })\n  };\n  render() {\n    return (\n     <NameContext.Provider value={{name: this.state.name, changeName: this.changeName}}>\n      {Routeconfig()}\n     </NameContext.Provider>\n    );\n  }\n};\n")])])]),n("p",[n("strong",[e._v("子组件中消费context")])]),e._v(" "),n("ul",[n("li",[e._v("Consumer：Consumer需要嵌套在生产者(provider)下面才能通过回调的方式拿到共享的数据源。当然也可以单独使用（例如不是父(index.tsx)子(hook_component.tsx)关系的list.tsx与index.tsx组件），那就只能消费到上文提到的defaultValue")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import { NameContext } from '@/index';\nclass List extends React.Component<initProps, initState> {\n  render () {\n    return (\n      <NameContext.Consumer>\n        {\n          (context) => (\n            <>\n              <div>this is list page</div>\n              <p>{context.name}</p>\n            </>\n          )\n        }\n      </NameContext.Consumer>\n    )\n  }\n};\n")])])]),n("p",[e._v("如果把子组件写成函数式组件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import * as React from 'react';\nimport { NameContext } from '@/index';\nexport function HookComponent () {\n  const context = React.useContext(NameContext);\n  return (\n    <>\n      <p>this is context {context.name}</p>\n      <button onClick={() => context.changeName()}>\n        cahngeContext\n      </button>\n    </>\n  );\n}\n")])])]),n("p",[e._v("参考代码："),n("a",{attrs:{href:"https://github.com/EvalGitHub/webpack_reactJS/blob/master/src/index.tsx",target:"_blank",rel:"noopener noreferrer"}},[e._v("index.txs、hook_componen.tsx、list.tsx"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"useref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[e._v("#")]),e._v(" useRef")]),e._v(" "),n("p",[e._v("useRef可用于获取元素节点，常见的操作就是获取input这个元素，实现初始化的自动获取焦点。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const Example:React.FC<InitProps> = (props:InitProps) => {\n  const inputEl = useRef(null);\n  const onBtnClick = () => {\n    inputEl.current.focus();\n  };\n  return (\n    <>\n      <input ref={inputEl} type="text"/>\n      <button onClick={onBtnClick}>clickBtn</button>\n    </>\n  );\n}\n')])])]),n("p",[e._v("上面的例子可以清晰看到，使用useRef获取了input这个元素节点，然后修改属性自动获取焦点。")]),e._v(" "),n("p",[n("strong",[e._v("useRef返回的ref对象在组件的整个生命周期内保持不变")])]),e._v(" "),n("p",[e._v("利用上面的这个特性能做规避很多问题：")]),e._v(" "),n("ol",[n("li",[e._v("timeout中读不到其他状态的新值")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('export default function App() {\n  const [flag, setValue] = React.useState(false);\n  function dealClick() {\n    setValue(!flag);\n    timer = window.setTimeout(() => {\n      setValue(!flag);\n      console.log(value);\n    }, 1000);\n  }\n  return (\n    <>\n      <p>{value ? "true" : "false"}</p>\n      <button onClick={dealClick}>click me </button>\n    </>\n  );\n}\n')])])]),n("p",[e._v("我们可以看到在点击按钮之后界面上显示true，1s之后打印出false,但是界面并没有更新为false，上面的问题就是"),n("strong",[e._v("setValue(!flag)")]),e._v("\n这句有问题，因为setValue是用来修改flag（flag是一个状态，对于状态的修改必须返回新的state才会是的视图更新）")]),e._v(" "),n("p",[e._v("使用UseRef来救场")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default function App() {\n  const [flag, setValue] = React.useState(false);\n  const valueRef = React.useRef(flag); \n  valueRef.current = flag;\n\n  function dealClick() {\n    setValue(!valueRef.current); \n    timer = window.setTimeout(() => {\n      setValue(!valueRef.current);\n    }, 1000);\n  }\n  return (\n    <>\n      <p>{valueRef.current}</p>\n      <button onClick={dealClick}>click me </button>\n    </>\n  );\n}\n")])])]),n("p",[e._v("因为valueRef.current对于flag来说就是一个新的状态。")]),e._v(" "),n("h2",{attrs:{id:"usereducer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer"}},[e._v("#")]),e._v(" useReducer")]),e._v(" "),n("p",[e._v("可以看做是useState的替代方案")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const [state, dispatch] = useReducer(reducer, initialArg, init);\n")])])]),n("p",[e._v("useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，"),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down",target:"_blank",rel:"noopener noreferrer"}},[e._v("因为你可以向子组件传递 dispatch 而不是回调函数"),n("OutboundLink")],1),e._v("。")]),e._v(" "),n("p",[e._v("示例代码参考官网："),n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer",target:"_blank",rel:"noopener noreferrer"}},[e._v("代码"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("strong",[e._v("比较useState，useReducer")])]),e._v(" "),n("p",[e._v("使用useState的情况：")]),e._v(" "),n("ul",[n("li",[e._v("state 为基本类型（也要看情况）")]),e._v(" "),n("li",[e._v("state 转换逻辑简单的场景")]),e._v(" "),n("li",[e._v("state 转换只会在当前组件中出现，其他组件不需要感知这个 state")]),e._v(" "),n("li",[e._v("多个 useState hooks 之间的 state 并没有关联关系")])]),e._v(" "),n("p",[e._v("使用 useReducer 的情况：")]),e._v(" "),n("ul",[n("li",[e._v("state 为引用类型（也要看情况）")]),e._v(" "),n("li",[e._v("state 转换逻辑比较复杂的场景")]),e._v(" "),n("li",[e._v("不同 state 之间存在较强的关联关系，应该作为一个 object，用一个 state 来表示的场景")])]),e._v(" "),n("h3",{attrs:{id:"usereducer的使用方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer的使用方法"}},[e._v("#")]),e._v(" useReducer的使用方法")]),e._v(" "),n("p",[e._v("store.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React from 'react';\nconst store = React.createContext(null);\n\nexport const initialState  = {\n // ....\n // ...\n}\n\nexport const reducer = (state, action) => {\n  switch (action.type) {\n    // ...\n  }\n}\n\nexport default store\n")])])]),n("p",[e._v("Provider根组件的挂载")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useReducer } from 'react'\nimport store, { reducer, initialState } from './store'\n\nfunction App() {\n  const [state, dispatch] = useReducer(reducer, initialState)\n  return (\n     <store.Provider value={{ state, dispatch }}>\n      <div/>\n     </store>\n  )\n}\n")])])]),n("p",[e._v("业务组件就可以直接使用：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import React, { useContext } from 'react'\nimport store from './store'\n\ncosnt Child = props => {\n  const { state, dispatch } = useContext(store)\n  // ...\n  return (\n    <>\n      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n    </>\n  )\n}\n")])])]),n("h2",{attrs:{id:"usecallback-usememo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecallback-usememo"}},[e._v("#")]),e._v(" useCallback，useMemo")]),e._v(" "),n("p",[e._v("这两个hook可用于优化react性能，在项目中经常会存在大批量的逻辑运算，其中有些函数是纯函数（没有任何副作用），相同的输入会返回相同的结果，但是如果不做处理，这些计算会在react组件重新渲染的时候会又一次的去执行，所有我们有必要将这些纯函数逻辑进行缓存，对于相同输入的\n情况直接去缓存结果，而不需要重新计算，这就是useCallback，useMemo存在的目的。")]),e._v(" "),n("blockquote",[n("p",[e._v("reack hook在组件diff的时候是会重新执行一遍的，这就意味着如果你在react组件中定义普通变量都会重新初始化，但是\n如果使用的是useState等hook函数声明的变量只能被是对应的函数更新。")])]),e._v(" "),n("p",[e._v("useCallback返回缓存的函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const memoizedCallback = useCallback(\n  () => {\n    doSomething(a, b);\n  },\n  [a, b],\n);\n")])])]),n("p",[e._v("useMemo返回缓存的变量")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const expensiveCount = useMemo(() => {\n  let sum = 0;\n  for (let i = 0; i < count * 100; i++) {\n    sum += i;\n  }\n  return sum;\n}, [count]);\n")])])]),n("p",[e._v("useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/hesongGG/article/details/84347484",target:"_blank",rel:"noopener noreferrer"}},[e._v("react中useMemo的用法"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"useimperativehandle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useimperativehandle"}},[e._v("#")]),e._v(" useImperativeHandle")]),e._v(" "),n("ul",[n("li",[e._v("使用 ref 时自定义暴露给父组件的实例值，useImperativeHandle 应当与 forwardRef 一起使用。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function FancyInput(props, ref) {\n  const inputRef = useRef();\n  useImperativeHandle(ref, () => ({\n    focus: () => {\n      inputRef.current.focus();\n    }\n  }));\n  return <input ref={inputRef} ... />;\n}\nFancyInput = forwardRef(FancyInput);\n")])])]),n("p",[e._v("另外的使用场景：")]),e._v(" "),n("blockquote",[n("p",[e._v("在react中函数组件是没有对应实例的，因此如果对组件使用ref，想获取组件的方法，会失败；useImperativeHandle提供了一种解决方案。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function OnLineModal(props:InitProps, ref:React.Ref<null>) {\n  const [modalVisible, setModalVisible] = React.useState<boolean>(false);\n  React.useImperativeHandle(ref, () : any => ({\n    setModalVisible: (flag:boolean) => setModalVisible(flag),\n  }));\n\n  return <ContainModal visible={modalVisible}/>;\n}\nexport const OnLineModalCom = React.forwardRef(OnLineModal); \n")])])]),n("p",[e._v("父组件：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function StateList(props:InitProps) {\n  const OnLineModalRef:React.Ref<null> = React.createRef();\n  function getRefVal() {\n    console.log(OnLineModalRef); // {setModalVisible:f}\n  }\n  return <section>\n    <button onClick={getRefVal}>get Ref value</button>\n    <OnLineModalCom ref = {OnLineModalRef}/>\n  </section>\n}\n")])])]),n("ul",[n("li",[e._v("进阶：如果是一个列表，每个列表项都是函数组件，想获取每一个函数组件的实例？")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const LIST = ["ce", "shi", "demo"];\nconst Item: React.FC<{\n  label: string;\n  idx: number;\n  ref: Ref;\n}> = forwardRef(({ label, idx }, ref) => {\n  const innerMethod = () => {\n    console.log(`${label}-${idx}`);\n  };\n\n  useImperativeHandle(ref, {\n    [`you example-${idx}`]: innerMethod\n  });\n  return <p>{label}</p>;\n});\n\nexport const MutilApp: React.FC = () => {\n  const globalRef = useRef(null);\n\n  const invokeAllMountMethod = () => {\n    const globalObject = globalRef?.current;\n    for (const [, method] of Object.entries(globalObject)) {\n      method();\n    }\n  };\n\n  return (\n    <>\n      <button\n        onClick={() => {\n          invokeAllMountMethod();\n        }}\n      >\n        INVOKE\n      </button>\n      {LIST.map((item, idx) => (\n        <Item label={item} idx={idx} key={item} ref={globalRef} />\n      ))}\n    </>\n  );\n};\n')])])]),n("p",[e._v("现在的代码如上，如果点击这个按钮，会发现最終的結果就是“demo-02”，\n那麽該如何获取到所有的实例呢？？")]),e._v(" "),n("blockquote",[n("p",[e._v("实际上，我们在前面也提到了这一点：一根垂直管道，你在上方投入了什么，下方拿到的就是什么， 我们始终只有一个globalRef，因此多次调用下最后一次的挂载覆盖掉了前面的。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import {Ref, useImperativeHandle, MutableRefObject } from "react";\n\nconst useMultiImperativeHandle = <T, K extends object>(\n  originRef: Ref,\n  convertRefObj: K,\n  deps?:any\n): void => {\n  return useImperativeHandle(\n    originRef,\n    () => {\n      return {\n        ...originRef.current,\n        ...convertRefObj\n      };\n    },\n    deps\n  );\n};\n\nexport default useMultiImperativeHandle;\n')])])]),n("p",[e._v("源码中使用：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const Item: React.FC<{\n  label: string;\n  idx: number;\n  ref: Ref;\n}> = forwardRef(({ label, idx }, ref) => {\n  const innerMethod = () => {\n    console.log(`${label}-${idx}`);\n  };\n\n  useMultiImperativeHandle(ref, {\n    [`method-from-${idx}`]: innerMethod\n  });\n\n  return <p>{label}</p>;\n});\n")])])]),n("h2",{attrs:{id:"uselayouteffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#uselayouteffect"}},[e._v("#")]),e._v(" useLayoutEffect")]),e._v(" "),n("blockquote",[n("p",[e._v("在所有的 DOM 变更之后同步调用effect。可以使用它来"),n("strong",[e._v("读取 DOM 布局并同步\n触发重渲染")]),e._v("。"),n("strong",[e._v("在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同\n步刷新")]),e._v("，也就是说它会阻塞浏览器绘制。所以尽可能使用 useEffect 以避免阻\n塞视觉更新。")])]),e._v(" "),n("p",[e._v("如果只是大量的数据处理，建议使用useEffect来进行处理；如果设计到动画效果，在首次展示的时候需要一个很流畅的体验，可以借助useLayoutEffect来进行")]),e._v(" "),n("p",[e._v("具体效果demo：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React, { useEffect, useLayoutEffect, useRef } from "react";\nimport "./styles.css";\n\nconst UseEffect: React.FC<any> = () => {\n  const box = useRef();\n  useEffect(() => {\n    (box.current as any).style.marginLeft = 100 + "px";\n  }, []);\n  return (\n    <div className="box box1" ref={box}>\n      useEffect\n    </div>\n  );\n};\nconst UseLayoutEffect: React.FC<any> = () => {\n  const box = useRef();\n  useLayoutEffect(() => {\n    (box.current as any).style.marginLeft = 100 + "px";\n  }, []);\n  return (\n    <div className="box box2" ref={box}>\n      UseLayoutEffect\n    </div>\n  );\n};\n\nexport default function App() {\n  return (\n    <div className="App">\n      <h1>刷新浏览器看下区别效果</h1>\n      <UseEffect />\n      <UseLayoutEffect />\n    </div>\n  );\n}\n')])])]),n("p",[e._v("可以看到使用useEffect的时候，界面动效会有点生硬；使用useLayoutEffect时候就很流畅；\n原因就是useLayoutEffect会在界面渲染之前就完成了计算更新，同步完成的，然后才会被浏览器\n渲染。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks 详解 【近 1W 字】+ 项目实战"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/5ec7372cf265da76de5cd0c9?utm_source=gold_browser_extension#heading-14",target:"_blank",rel:"noopener noreferrer"}},[e._v("react hook进阶"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.zhihu.com/question/350523308/answer/858145147",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用 React Hooks 的心智负担"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);