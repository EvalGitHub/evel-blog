(window.webpackJsonp=window.webpackJsonp||[]).push([[143],{609:function(e,a,t){"use strict";t.r(a);var s=t(28),l=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"编写一个简单的loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编写一个简单的loader"}},[e._v("#")]),e._v(" 编写一个简单的loader")]),e._v(" "),t("p",[e._v("webpack是一个js模块打包机器，至于不是js的文件的处理一般需要相关的loader做处理。")]),e._v(" "),t("p",[e._v("loader本质上是一个函数：基于CommonJS规范的函数模块（接受一个参数这个参数可能是源文件也可能是其他loader处理后的结果）")]),e._v(" "),t("blockquote",[t("p",[e._v("replaceLoader.js")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = function (source) { \n\t// 不能写箭头函数，因为this会有很多loader参数,如果是箭头函数则会丢失\n  let result = source.replace('loaderAsync', 'loader1')\n  this.callback(null, result) // 支持返回多个参数\n}\n")])])]),t("p",[e._v("source包含的就是打包之后的文件内容，因此通过loader,我们可以轻松的从source中获取内容然后做相关的处理。")]),e._v(" "),t("p",[e._v("上面的loader的作用是将代码中的“loaderAsync”替换为“loader1”")]),e._v(" "),t("p",[e._v("补充一点：如果操作是异步的我们可以使用webpack提供的this.async方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = function (source) { \n  console.log(this.query)\n  let result = source.replace('loader', this.query.name)\n  // this.callback(null, result) // 支持返回多个参数\n  const callback = this.async(); // 异步loader\n  setTimeout(() => {\n    callback(null, result)\n  }, 1000)\n}\n")])])]),t("h2",{attrs:{id:"loader中如何获取options的配制参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loader中如何获取options的配制参数"}},[e._v("#")]),e._v(" loader中如何获取options的配制参数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('module:{\n  rules:[\n    {\n      test: /\\.js$/,\n      exclude: /node_modules/, \n      loader: "babel-loader",\n      options: {\n        "plugins": [\n          "dynamic-import-webpack"\n        ]\n      }\n    }\n  ]\n}\n')])])]),t("p",[e._v("就象上面的options的参数怎么在loader中获取这个参数了")]),e._v(" "),t("p",[t("strong",[e._v("loader-utils")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const loaderUtils = require("loader-utils")\nmodule.exports = function(source) {\n  // 获取开发者配置的 options\n  const options = loaderUtils.getOptions(this)\n  // some magic...\n  return content\n}\n')])])]),t("h2",{attrs:{id:"区分loader与plugin的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区分loader与plugin的区别"}},[e._v("#")]),e._v(" 区分loader与plugin的区别")]),e._v(" "),t("blockquote",[t("p",[e._v("loader其实是一个转换器，执行单纯的文件转换操作；\nplugin 是一个拓展器，他不直接操作文件本身，而是基于事件机制工作，监听webpack打包过程的某些事件，见缝插针，修改打包结果。")])]),e._v(" "),t("p",[e._v("相关示例代码："),t("a",{attrs:{href:"https://git.lug.ustc.edu.cn/EvalGitHub/wepack-loader-plugin",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://git.lug.ustc.edu.cn/EvalGitHub/wepack-loader-plugin"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("webpack文档："),t("a",{attrs:{href:"https://www.webpackjs.com/api/loaders/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.webpackjs.com/api/loaders/"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=l.exports}}]);