(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{533:function(e,t,n){"use strict";n.r(t);var a=n(28),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"react全局方法的使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react全局方法的使用"}},[e._v("#")]),e._v(" react全局方法的使用")]),e._v(" "),n("h2",{attrs:{id:"使用react-createelement创建组件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用react-createelement创建组件"}},[e._v("#")]),e._v(" 使用React.createElement创建组件")]),e._v(" "),n("blockquote",[n("p",[e._v("基本语法：React.createElement( type, [props], [...children] )")])]),e._v(" "),n("p",[e._v("在react中创建一个组件的最常用方式：代码如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import * as React from 'react';\nimport  * as style from './index.scss';\nexport class CreateEle extends React.Component {\n  render () {\n    return (\n      <div id='one' className={style.two}'>\n        <span id='spanOne'>只是测试代码第一个span</span>\n        <span id='spanTwo'>只是测试代码第二个span</span>\n      </div>\n    )\n  }\n}\n")])])]),n("p",[e._v("使用React.createElement的方式：代码如下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export class CreateEle extends React.Component {\n  render () {\n    return (\n      <div>\n        {\n          React.createElement(\n            'div', \n            {id: 'one', className: style.two },\n            React.createElement('span', { id: 'spanOne'}, '只是测试代码第一个span 标签'),\n            React.createElement('span', { id: 'spanTwo'}, '只是测试代码第二个span 标签'),\n          )\n        }\n      </div>\n    )\n  }\n}\n")])])]),n("h2",{attrs:{id:"react-cloneelement"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-cloneelement"}},[e._v("#")]),e._v(" React.cloneElement")]),e._v(" "),n("p",[e._v("以 element 元素为样板克隆并返回新的 React 元素。"),n("strong",[e._v("返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果")]),e._v("。新的子元素将取代现有的子元素，而来自原始元素的 key 和 ref 将被保留")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("React.cloneElement(\n  element,\n  [props],\n  [...children]\n)\n")])])]),n("ul",[n("li",[e._v("demo:")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function FatherComponent({ children }){\n    const newChildren = React.cloneElement(children, { age: 18})\n    return <div> { newChildren } </div>\n}\n\nfunction SonComponent(props){\n    console.log(props)\n    return <div>hello,world</div>\n}\n\nclass Index extends React.Component{    \n    render(){      \n        return <div className="box" >\n            <FatherComponent>\n                <SonComponent name="alien"  />\n            </FatherComponent>\n        </div>   \n    }\n}\n')])])]),n("p",[n("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/react-api.html#cloneelement",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考官网"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"reactdom-createportal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-createportal"}},[e._v("#")]),e._v(" ReactDOM.createPortal")]),e._v(" "),n("p",[e._v("可以使用这个方法将子节点渲染到父组件意外的DOM节点")]),e._v(" "),n("blockquote",[n("p",[e._v("ReactDOM.createPortal(child, container)")])]),e._v(" "),n("ul",[n("li",[e._v("child")])]),e._v(" "),n("p",[e._v("是任何可渲染的React子元素（元素，字符串，fragment）")]),e._v(" "),n("ul",[n("li",[e._v("container")])]),e._v(" "),n("p",[e._v("是一个dom元素")]),e._v(" "),n("blockquote",[n("p",[e._v("通常来讲，当你从组件的 render 方法返回一个元素时，该元素将被挂载到 DOM 节点中离其最近的父节点：")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("render() {\n  // React 挂载了一个新的 div，并且把子元素渲染其中\n  return (\n    <div>\n      {this.props.children}\n    </div>\n  );\n}\n")])])]),n("p",[e._v("然而，有时候将子元素插入到 DOM 节点中的不同位置也是有好处的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("render() {\n  // React 并*没有*创建一个新的 div。它只是把子元素渲染到 `domNode` 中。\n  // `domNode` 是一个可以在任何位置的有效 DOM 节点。\n  return ReactDOM.createPortal(\n    this.props.children,\n    domNode\n  );\n}\n")])])]),n("h2",{attrs:{id:"使用react-memo提升性能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用react-memo提升性能"}},[e._v("#")]),e._v(" 使用React.memo提升性能")]),e._v(" "),n("p",[e._v("react性能提升，只在props属性更新了，才会触发重新渲染，功能同React.PureComponent，但是他只使用与函数组件。")]),e._v(" "),n("ul",[n("li",[e._v("如果你的"),n("strong",[e._v("函数组件")]),e._v("在给定相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用。")])]),e._v(" "),n("p",[e._v("使用方式：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function MyComponent(props) {\n  /* 使用 props 渲染 */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  如果把 nextProps 传入 render 方法的返回结果与\n  将 prevProps 传入 render 方法的返回结果一致则返回 true，\n  否则返回 false\n  */\n}\nexport default React.memo(MyComponent, areEqual);\n")])])]),n("p",[e._v("一个简单例子：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function areEqual(prevProps, nextProps) {\n  if (prevProps.val === nextProps.val) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\n// React.memo()两个参数,第一个是纯函数,第二个是比较函数\nexport default React.memo(function twentyChild(props) {\n  console.log("MemoSon rendered : " + Date.now());\n  return <div>{props.val}</div>;\n}, areEqual);\n')])])]),n("p",[n("strong",[e._v("补充：")]),e._v(" React.PureComponent在比较组件前后状态是否相等的时候使用的是一种浅比较（基础值类型比较是否相等，引用类型比较健值对）")]),e._v(" "),n("h2",{attrs:{id:"使用react-purecomponent提升类组价的性能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用react-purecomponent提升类组价的性能"}},[e._v("#")]),e._v(" 使用React.pureComponent提升类组价的性能")]),e._v(" "),n("p",[e._v("React.pureComponent与React.memo功能类似(避免比必要的重新渲染，所有的生命周期都不会执行)，不过前者是针对类组件，后者是针对函数组件")]),e._v(" "),n("p",[e._v("实现原理：对父组件的props，以及自己内部的state值，使用**shouldComponentUpdate(nextProps, nextState)**来进行浅比较，判读是否需要更新")]),e._v(" "),n("p",[n("strong",[e._v("使用条件：")])]),e._v(" "),n("ul",[n("li",[e._v("要state, props是一个比较简单的基本类型数据（因为只会简单的比较键值是否相等）")])]),e._v(" "),n("blockquote",[n("p",[e._v("如果数据结构太复杂可能不会监测到变化；假设数据结构就是很复杂，但是又使用到了pureComponent，我们需要在修改父组件state中那个用于子组件的props，每一次都是返回一个新的引用（新数组[]，新的对象{}）")])]),e._v(" "),n("p",[e._v("参考链接："),n("a",{attrs:{href:"https://www.jianshu.com/p/0d0587fc33de",target:"_blank",rel:"noopener noreferrer"}},[e._v("React中PureComponent的浅比较"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"react-forwardref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-forwardref"}},[e._v("#")]),e._v(" React.forwardRef")]),e._v(" "),n("ul",[n("li",[e._v("利用forwardRef进行值传递")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('import React from "react";\nimport "./styles.css";\nimport { Pcom } from "./pCom";\nimport { Ppcom } from "./ppCom";\nexport default function App() {\n  let [num, setNum] = React.useState(0);\n  function addNum() {\n    setNum(++num);\n  }\n  return (\n    <div className="App">\n      <button onClick={addNum}>add num:</button>\n      <Pcom\n        content={React.forwardRef((props, ref) => (\n          // props是Pcom传递的属性值\n          <Ppcom num={num} {...props} />\n        ))}\n      />\n    </div>\n  );\n}\n')])])]),n("p",[e._v("pCom.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('export function Pcom(props) {\n  const Content = props.content;\n  return (\n    <>\n      <Content name="name" age="age" />\n    </>\n  );\n}\n')])])]),n("p",[e._v("ppCom.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export function Ppcom(props) {\n  return (\n    <>\n      <p>{props.num}</p>\n      <p>{props.age}</p>\n      <p>{props.name}</p>\n    </>\n  );\n}\n")])])]),n("ul",[n("li",[e._v("利用forwardRef转发Ref")])]),e._v(" "),n("p",[e._v("如果父组件想获取孙组件的某一个dom, 这种隔代ref的获取引用")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Son (props){\n    const { grandRef } = props\n    return <div>\n        <div> i am alien </div>\n        <span ref={grandRef} >这个是想要获取元素</span>\n    </div>\n}\n\nclass Father extends React.Component{\n    constructor(props){\n        super(props)\n    }\n    render(){\n        return <div>\n            <Son grandRef={this.props.grandRef}  />\n        </div>\n    }\n}\n\nconst NewFather = React.forwardRef((props,ref)=><Father grandRef={ref}  {...props} />  )\n\nclass GrandFather extends React.Component{\n    constructor(props){\n        super(props)\n    }\n    node = null \n    componentDidMount(){\n        console.log(this.node)\n    }\n    render(){\n        return <div>\n            <NewFather ref={(node)=> this.node = node } />\n        </div>\n    }\n}\n")])])]),n("h2",{attrs:{id:"react-lazy-react-suspense"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-lazy-react-suspense"}},[e._v("#")]),e._v(" React.Lazy && React.Suspense")]),e._v(" "),n("blockquote",[n("p",[e._v("React.lazy 和 Suspense 技术还不支持服务端渲染。如果你想要在使用服务端渲染的应用中使用，我们推荐 Loadable Components 这个库")])]),e._v(" "),n("ul",[n("li",[e._v("React.Lazy和React.Suspense可以达到组件动加载的效果")])]),e._v(" "),n("p",[n("strong",[e._v("React.lazy 接受一个函数，这个函数需要动态调用 import()。它必须返回一个 Promise ，该 Promise 需要 resolve 一个 default export 的 React 组件。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import Test from './comTest'\nconst LazyComponent =  React.lazy(()=> new Promise((resolve)=>{\n  setTimeout(()=>{ // 两秒之后才返回组件\n    resolve({\n      default: ()=> <Test />\n    })\n  },2000)\n}));\n\nclass index extends React.Component{   \n  render(){\n    return <div className=\"context_box\" style={ { marginTop :'50px' } }   >\n      <React.Suspense fallback={ <div className=\"icon\"><SyncOutlined spin /></div>}>\n        <LazyComponent />\n      </React.Suspense>\n    </div>\n  }\n}\n")])])]),n("h2",{attrs:{id:"react-fragment"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-fragment"}},[e._v("#")]),e._v(" React.Fragment")]),e._v(" "),n("ul",[n("li",[e._v("常用于render函数返回多个标签的情况下，进行包裹。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<React.Fragment>\n  <div>1</div> \n  <div>1</div> \n  <div>1</div> \n</React.Fragment>\n")])])]),n("h2",{attrs:{id:"react-strictmode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-strictmode"}},[e._v("#")]),e._v(" React.StrictMode")]),e._v(" "),n("blockquote",[n("p",[e._v("严格模式，用于检测react项目中的潜在的问题; 与Fragment一样， StrictMode不会渲染任何可见的UI 。它为其后代元素触发额外的检查和警告;\n严格模式检查仅在开发模式下运行；它们不会影响生产构建")])]),e._v(" "),n("ul",[n("li",[e._v("实践:识别不安全的生命周期")])]),e._v(" "),n("h2",{attrs:{id:"react-createcontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-createcontext"}},[e._v("#")]),e._v(" React.createContext")]),e._v(" "),n("p",[e._v("[见《react函数编程hook基本用法》]")]),e._v(" "),n("h2",{attrs:{id:"reactdom-unstable-batchedupdates"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-unstable-batchedupdates"}},[e._v("#")]),e._v(" ReactDOM.unstable_batchedUpdates")]),e._v(" "),n("p",[e._v("解决多次render问题")]),e._v(" "),n("p",[e._v("在react 合成事件中如果多次连续使用setState改变一个state的值，他只会执行一次；一次常见的解决方式就是在react合成事件之外去处理，\n例如使用setTimeout, promise简单包裹下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("this.state = { number: 1}\nhandleChangeNum =()=>{\n  Promise.resolve().then(()=>{\n      this.setState({ number : this.state.number + 1 })\n      console.log(this.state.number)\n      this.setState({ number : this.state.number + 1 })\n      console.log(this.state.number)\n      this.setState({ number : this.state.number + 1 })\n      console.log(this.state.number)\n  })\n}\n")])])]),n("blockquote",[n("p",[e._v("2, 3, 4")])]),e._v(" "),n("p",[e._v("但是这存在另一个问题，回重复渲染三次，那么该如何优化呢？？")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("this.state = { number: 1}\nhandleChangeNum =()=>{\n  ReactDOM.unstable_batchedUpdates(() => {\n    Promise.resolve().then(()=>{\n        this.setState({ number : this.state.number + 1 })\n        console.log(this.state.number)\n        this.setState({ number : this.state.number + 1 })\n        console.log(this.state.number)\n        this.setState({ number : this.state.number + 1 })\n        console.log(this.state.number)\n    })\n  })\n}\n")])])]),n("h2",{attrs:{id:"reactdom-flushsync"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-flushsync"}},[e._v("#")]),e._v(" ReactDOM.flushSync")]),e._v(" "),n("blockquote",[n("p",[e._v("可以将回调函数中的更新任务，放在一个较高的优先级中。我们知道react设定了很多不同优先级的更新任务。\n如果一次更新任务在flushSync回调函数内部，那么将获得一个较高优先级的更新。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import ReactDOM from 'react-dom'\nclass Index extends React.Component{\n  state={ number:0 }\n  handerClick=()=>{\n    setTimeout(()=>{\n      this.setState({ number: 1  });\n      console.log(this.state.number);\n    })\n    this.setState({ number: 2  })\n    ReactDOM.flushSync(()=>{\n      this.setState({ number: 3  })\n    })\n    this.setState({ number: 4  })\n  }\n  render(){\n    const { number } = this.state\n    console.log(number) // 打印什么？？\n    return <div>\n      <div>{ number }</div>\n      <button onClick={this.handerClick} >测试flushSync</button>\n    </div>\n  }\n}\n")])])]),n("blockquote",[n("p",[e._v("3, 4, 1, 1")])]),e._v(" "),n("p",[e._v("结果分析：ReactDOM.flushSync中的优先执行， 2， 4批量更新只会执行后面的一个，setTimeout延时执行最慢,但是他是同步,因为处于非react函数，合成事件中，他就是同步执行，所以能立马获取到number的值。")]),e._v(" "),n("h2",{attrs:{id:"reactdom-finddomnode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reactdom-finddomnode"}},[e._v("#")]),e._v(" ReactDOM.findDOMNode")]),e._v(" "),n("blockquote",[n("p",[e._v("ReactDOM.findDOMNode(component)")])]),e._v(" "),n("p",[e._v("用于访问组件DOM元素节点，react推荐使用ref模式")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("findDOMNode只能用在已经挂载的组件上。")])]),e._v(" "),n("li",[n("p",[e._v("如果组件渲染内容为 null 或者是 false，那么 findDOMNode返回值也是 null。")])]),e._v(" "),n("li",[n("p",[e._v("findDOMNode 不能用于函数组件。")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Index extends React.Component{\n    handerFindDom=()=>{\n        console.log(ReactDOM.findDOMNode(this))\n    }\n    render(){\n        return <div style={{ marginTop:'100px' }} >\n            <div>hello,world</div>\n            <button onClick={ this.handerFindDom } >获取容器dom</button>\n        </div>\n    }\n}\n")])])]),n("h2",{attrs:{id:"react-unmountcomponentatnode"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-unmountcomponentatnode"}},[e._v("#")]),e._v(" React.unmountComponentAtNode")]),e._v(" "),n("p",[e._v("从 DOM 中卸载组件，会将其事件处理器和 state 一并清除。如果指定容器上没有对应已挂载的组件，这个函数什么也不会做。如果组件被移除将会返回 true ，如果没有组件可被移除将会返回  false 。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function Text(){\n  return <div>hello,world</div>\n}\n\nclass Index extends React.Component{\n  node = null\n  constructor(props){\n    super(props)\n    this.state={\n      number:1,\n    }\n  }\n\n  componentDidMount(){\n    /*  组件初始化的时候，创建一个 container 容器 */\n    ReactDOM.render(<Text/> , this.node )\n  }\n\n  handerClick=()=>{\n    /* 点击卸载容器 */ \n    const state =  ReactDOM.unmountComponentAtNode(this.node)\n    console.log(state)\n  }\n\n  render(){\n    return <div  style={{ marginTop:'50px' }}  > \n      <div ref={ ( node ) => this.node = node  }  ></div>  \n      <button onClick={ this.handerClick } >click me</button>\n    </div>\n  }\n}\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);