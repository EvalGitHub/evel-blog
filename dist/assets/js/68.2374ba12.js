(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{523:function(n,e,s){"use strict";s.r(e);var t=s(28),a=Object(t.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"收集一些不寻常的异步问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#收集一些不寻常的异步问题"}},[n._v("#")]),n._v(" 收集一些不寻常的异步问题")]),n._v(" "),s("h2",{attrs:{id:"红灯-3s-亮一次-绿灯-1s-亮一次-黄灯-2s-亮一次-如何让三个灯不断交替重复亮灯"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#红灯-3s-亮一次-绿灯-1s-亮一次-黄灯-2s-亮一次-如何让三个灯不断交替重复亮灯"}},[n._v("#")]),n._v(" 红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function red () {\n  console.log('red');\n}\nfunction green() {\n  console.log('green');\n}\nfunction yellow() {\n  console.log('yellow')\n}\n\nfunction dealFun(time, funCallback) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      funCallback();\n      resolve();\n    }, time)\n  }) \n}\n\nfunction step() {\n  dealFun(3000, red).then(() => {\n    dealFun(1000, green)\n  }).then(() => {\n    dealFun(2000, yellow)\n  }).then(() => step());\n}\nstep();\n")])])]),s("p",[n._v("尝试把上面的代码放在浏览器中会发现，执行速度并不是我们预期的那样，仔细分析会发现问题就出现在")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function step() {\n  dealFun(3000, red).then(() => {\n    dealFun(1000, green)\n  }).then(() => {\n    dealFun(2000, yellow)\n  }).then(() => step());\n}\n")])])]),s("p",[n._v("在resolve中如果不手动返回resolve，会默认返回一个resoive")]),n._v(" "),s("p",[n._v("用代码翻译：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function step() {\n  dealFun(3000, red).then(() => {\n    dealFun(1000, green)\n    return Promise.resolve();\n  }).then(() => {\n    dealFun(2000, yellow)\n    return Promise.resolve();\n  }).then(() => step());\n}\n")])])]),s("p",[n._v("会发现"),s("strong",[n._v("return Promise.resolve();")]),n._v(" 并不会等待**dealFun(1000, green)**执行完毕再执行，所以导致执行效果与我们预期不同；")]),n._v(" "),s("p",[n._v("解决思路：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function step() {\n  dealFun(3000, red).then(() => {\n    return dealFun(1000, green)\n  }).then(() => {\n    return dealFun(2000, yellow)\n  }).then(() => step());\n}\n\n// or \n\nfunction step() {\n  dealFun(3000, red).then(() => dealFun(1000, green)).then(() => dealFun(2000, yellow)).then(() => step());\n}\n")])])]),s("p",[n._v("这样的话就阻止了默认的返回resolve。")]),n._v(" "),s("h2",{attrs:{id:"请写出下面的结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请写出下面的结果"}},[n._v("#")]),n._v(" 请写出下面的结果？")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("async function async1() {\n  console.log('async1 start')\n  await async2()\n  console.log('async1 end')\n}\n\nasync function async2() {\n  console.log('async2')\n}\n\nconsole.log('script start')\n\nsetTimeout(function() {\n  console.log('setTimeout') \n}, 0)  \n\nasync1()\n\nnew Promise(function(resolve) {\n  console.log('promise1')\n  resolve()\n}).then(function() {\n  console.log('promise2')\n})\n\nconsole.log('script end')\n")])])]),s("p",[n._v("async/await是promise的语法糖（对promise做的二次封装）。")]),n._v(" "),s("p",[n._v("在一开始写出的答案是：")]),n._v(" "),s("blockquote",[s("p",[n._v("script start -> async1 start -> promise1 -> script end  -> async2 -> async1 end -> promise2 -> setTimeout")])]),n._v(" "),s("p",[n._v("但是真正的答案：")]),n._v(" "),s("blockquote",[s("p",[n._v("script start -> async1 start -> async2 -> promise1 -> script end -> async1 end -> promise2 -> setTimeout")])]),n._v(" "),s("p",[n._v("上面的答案出现的错误就在与没能真正理解async/await，所以导致对于async2的执行时间判断有偏差。")]),n._v(" "),s("p",[n._v("先回顾下js基础知识，js中存在的任务可分为两种，一中是可以立即执行的同步任务，一种是需要等待某些时间才可以执行的异步任务，对于单线程的js来说，如果不对异步任务做特殊处理就会导致执行阻塞。因此js中出现了异步任务队列（专门用于收集异步任务，待主程序执行完同步任务，再来循环遍历这个异步人任务队列，这就是常说的js事件循环event loop）。")]),n._v(" "),s("p",[s("strong",[n._v("同步任务")])]),n._v(" "),s("blockquote",[s("p",[n._v("当前主线程将要消化执行的任务，这些任务一起形成执行栈（execution context stack）")])]),n._v(" "),s("p",[s("strong",[n._v("异步任务")])]),n._v(" "),s("blockquote",[s("p",[n._v("不进入主线程，而是进入任务队列（task queue），即不会马上进行的任务。")])]),n._v(" "),s("ul",[s("li",[n._v("异步任务可分：\n"),s("ul",[s("li",[n._v("宏任务\n"),s("ul",[s("li",[n._v("setTimeout")]),n._v(" "),s("li",[n._v("setInterval")]),n._v(" "),s("li",[n._v("I/O")]),n._v(" "),s("li",[n._v("事件")]),n._v(" "),s("li",[n._v("postMessage")]),n._v(" "),s("li",[n._v("setImmediate (Node.js，浏览器端该 API 已经废弃)")]),n._v(" "),s("li",[n._v("requestAnimationFrame")]),n._v(" "),s("li",[n._v("UI 渲染")])])]),n._v(" "),s("li",[n._v("微任务\n"),s("ul",[s("li",[n._v("Promise.then")]),n._v(" "),s("li",[n._v("MutationObserver")]),n._v(" "),s("li",[n._v("process.nextTick (Node.js)")])])])])])]),n._v(" "),s("p",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s/g_-blGV4CVF5EogYZaPMzQ",target:"_blank",rel:"noopener noreferrer"}},[n._v("Event Loop和js引擎，渲染引擎的关系"),s("OutboundLink")],1)]),n._v(" "),s("p",[s("strong",[n._v("关于执行顺序总体来说就是： 同步任务 >  微任务 > 宏任务")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("分析： \n\n先看同步任务： \n\nconsole.log('script start') 优先执行  --- script start (1)\n\nsetTimeout  添加异步任务队列\n\nasync1()\n  console.log('async1 start')      ----- async1 start (2)\n  await async2()                   ----- async2       (3)\n  console.log('async1 end') 添加到异步任务队列\n\n\nPromise() \n  console.log('promise1')           ---- promise1     (4)\n  console.log('promise2') 添加到异步任务队列\n\nconsole.log('script end')           ---- script end   (5)\n\n至此同步任务执行完毕，开始执行异步任务\n微任务Promise.then优先与setTimeout\n\nconsole.log('async1 end')          ---- async1 end    (6)\n\nconsole.log('promise2')            ---- promise2      (7)\n\nsetTimeout                          --- setTimeout    (8)\n")])])]),s("p",[s("strong",[n._v("补充两点：")])]),n._v(" "),s("ul",[s("li",[n._v("Promise.then是异步，但是Promise不是异步 因此 “console.log('promise1')“会同步执行。")]),n._v(" "),s("li",[n._v("async/await是promise的语法糖\n"),s("ul",[s("li",[n._v("async 声明的函数，其返回值必定是 promise 对象，如果没有显式返回 promise 对象，也会用 Promise.resolve() 对结果进行包装，保证返回值为 promise 类型")]),n._v(" "),s("li",[n._v("如果 await 右侧表达逻辑是个 promise，让出主线程，继续执行 async 函数外的同步代码，等待同步任务结束后，且该 promise 被 resolve 时，继续执行 await 后面的逻辑\n如果 await 右侧表达逻辑不是 promise 类型，那么仍然异步处理，将其理解包装为 promise， async 函数之外的同步代码执行完毕之后，会回到 async 函数内部，继续执行 await 之后的逻辑")])])])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("async function async1() {\n  console.log('async1 start')\n  await async2()\n  console.log('async1 end')\n}\n")])])]),s("p",[n._v("等价与")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function async1() {\n  new Promise(function(resolve, reject) {\n    console.log('async1 start')\n    async2()\n    resolve()\n  })\n}\n\nfunction async2 () {\n  return new Promise(function(resolve, reject) {\n    console.log('async2')\n    resolve()\n  }).then(() => {\n    console.log('async1 end')\n  })\n}\nasync1()\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);