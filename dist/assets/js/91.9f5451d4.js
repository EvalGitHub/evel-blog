(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{546:function(t,e,v){"use strict";v.r(e);var a=v(28),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"react-对比-vue-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-对比-vue-的区别"}},[t._v("#")]),t._v(" react 对比 vue 的区别")]),t._v(" "),v("h2",{attrs:{id:"核心思想不同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#核心思想不同"}},[t._v("#")]),t._v(" 核心思想不同")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("vue 降低前端开发的门槛")]),t._v(" "),v("ul",[v("li",[t._v("Vue推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集）")]),t._v(" "),v("li",[t._v("vue推崇的组件配置的方式，template，data，methods，watcher")]),t._v(" "),v("li",[t._v("vue提供了许多便于开发的指令：v-if，v-show，v-bind；而react却没有")]),t._v(" "),v("li",[t._v("vue的所有解决方案都是官方提供的vue-router，vuex")])])]),t._v(" "),v("li",[v("p",[t._v("react 推崇编程的最佳实践")]),t._v(" "),v("ul",[v("li",[t._v("React推崇函数式编程（纯组件），数据不可变以及单向数据流")]),t._v(" "),v("li",[t._v("rjx语法，hook无class编程")]),t._v(" "),v("li",[t._v("只关注react的维护，把其他的对应工具交给社区")])])])]),t._v(" "),v("h2",{attrs:{id:"响应式原理不同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理不同"}},[t._v("#")]),t._v(" 响应式原理不同")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("vue使用的是数据劫持依赖收集，核心是Object.defineproperty(vue2)，proxy(vue3)，用户不需要可以关注数据的变化，当数据变化的时候，最自动触发视图的更新。")])]),t._v(" "),v("li",[v("p",[t._v("react强调state的不可变，每一个更新state必须返回一个新的对象，不对数据的改变进行监控；需要开发者手动触发setState，forceUdare，ReactDom.render()去触发更新。")])])]),t._v(" "),v("h2",{attrs:{id:"事件机制不同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事件机制不同"}},[t._v("#")]),t._v(" 事件机制不同")]),t._v(" "),v("p",[t._v("react使用了一种合成事件机制，会将每个元素上绑定的事件委托到doucment，这么做的目的是为了解决事件的兼容性问题（不同浏览器，不同运行环境reactNative）。")]),t._v(" "),v("p",[t._v("vue使用web标准事件，兼容性问题有开发者自己解决。")]),t._v(" "),v("h2",{attrs:{id:"diff算法的异同"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#diff算法的异同"}},[t._v("#")]),t._v(" diff算法的异同？？")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("相同点：")]),t._v(" "),v("ul",[v("li",[t._v("对于不同类型的组件或节点直接删除然后新建")]),t._v(" "),v("li",[t._v("同一层次的相同类型节点可以 通过key进行diff优化")])])]),t._v(" "),v("li",[v("p",[t._v("不同点：")]),t._v(" "),v("ul",[v("li",[t._v("vue在进行节点diff时使用的是双向链表，边对比边更新DOM")]),t._v(" "),v("li",[t._v("React使用呢diff队列保存需要更新的DOM得到patch树，然后统一更新")])])])])])}),[],!1,null,null,null);e.default=r.exports}}]);