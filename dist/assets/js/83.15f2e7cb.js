(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{534:function(e,t,n){"use strict";n.r(t);var a=n(28),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"react合成事件与原生事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react合成事件与原生事件"}},[e._v("#")]),e._v(" react合成事件与原生事件")]),e._v(" "),n("h3",{attrs:{id:"合成事件存在的原因"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合成事件存在的原因"}},[e._v("#")]),e._v(" 合成事件存在的原因？")]),e._v(" "),n("p",[e._v("如果DOM上绑定过多事件处理函数，整个页面响应以及内存占用都会有影响，另外还有各种兼容性引起的事件差异性问题，所以react实现了一个中间层---合成事件（SyntheticEvent）。")]),e._v(" "),n("p",[e._v("在原生js开发中如果一个元素被重复绑定相同事件，则这些事件会按绑定顺序依次执行，如果想终止，可以使用 "),n("strong",[e._v("event.stopImmediatePropagation")]),e._v("。")]),e._v(" "),n("p",[e._v("MDN：\n"),n("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"合成事件的原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合成事件的原理"}},[e._v("#")]),e._v(" 合成事件的原理？")]),e._v(" "),n("p",[e._v("react中，如果需要绑定事件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<div onClick={this.getUserName.bind(this)}>\n  获取用户名\n</div>\n")])])]),n("p",[e._v("react并不是将事件真正的绑定在这个div元素上，而是在document处监听所有支持的事件，当事件发生并"),n("strong",[e._v("冒泡")]),e._v("至document处时，react将事件内容封装并交由真正的处理函数运行。")]),e._v(" "),n("h3",{attrs:{id:"如何在react中使用原生事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何在react中使用原生事件"}},[e._v("#")]),e._v(" 如何在react中使用原生事件？")]),e._v(" "),n("p",[e._v("在一些情况下我们拥有使用原生事件的必要原因（window上的操作，全局弹窗关闭）\n与合成事件相比，原生事件是真实绑定在DOM上，所以一般在componentDidMount阶段进行操作，\n在componentWillUnmount进行事件的解除避免内存泄漏。")]),e._v(" "),n("blockquote",[n("p",[e._v("1）除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()；\n你需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。")])]),e._v(" "),n("blockquote",[n("p",[e._v("2）如果因为某些原因，当你需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。")])]),e._v(" "),n("h4",{attrs:{id:"事件池"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件池"}},[e._v("#")]),e._v(" 事件池")]),e._v(" "),n("blockquote",[n("p",[e._v("SyntheticEvent(合成事件是合并而来)，这意味着这个对象可能会被重用，而且在事件回调函数被调用之后，所有的属性都会无效，出于性能考虑，你不能通过异步访问事件。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(' deleteTest (event:any) {\n \t // event.persist()；\n    console.log(event);\n    console.log(event.nativeEvent);\n    console.log(event.type); // => "click"\n    const eventType = event.type; // => "click"\n  \n    setTimeout(function() {\n      console.log(event.type); // => null 报错\n      console.log(eventType); // => "click"\n    }, 0);\n  };\n')])])]),n("p",[e._v("如果你想异步访问事件属性，你需在事件上调用 event.persist()，此方法会从池中移除合成事件，允许用户代码保留对事件的引用。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class Demo extends React.PureComponent {\n    componentDidMount() {\n        const $this = ReactDOM.findDOMNode(this)\n        $this.addEventListener('click', this.onDOMClick, false)\n    }\n\n    onDOMClick = evt => {\n       // ...\n    }\n\n    render() {\n        return (\n          <div>Demo</div>\n        )\n    }\n}\n\n")])])]),n("h3",{attrs:{id:"合成事件与原生事件的混合使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#合成事件与原生事件的混合使用"}},[e._v("#")]),e._v(" 合成事件与原生事件的混合使用？")]),e._v(" "),n("ul",[n("li",[e._v("合成事件监听器是统一注册在document上，且仅有冒泡阶段。所以原生事件的监听器响应要比合成事件的监听器早。")]),e._v(" "),n("li",[e._v("阻止原生事件的冒泡会阻止合成事件的监听执行。")])]),e._v(" "),n("p",[e._v("几个例子学习下？\n[前提是都是点击子元素触发事件；事件都是先捕获-执行-冒泡]")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  onParentDOMClick = (evt:any) => {\n      console.log('captrue: parent dom event')\n  }\n\n  onChildDOMClick = (evt:any) => {\n      console.log('bubble: child dom event')\n  }    \n\n  onParentClick = (evt:any) => {\n      console.log('capture: parent react event')\n  }\n\n  onChildClick = (evt:any) => {   \n    console.log('bubble: child react event')\n  }\n\n  componentDidMount () {\n    const $parent:any = ReactDOM.findDOMNode(this)\n    const $child = $parent.querySelector('.child')\n    $parent.addEventListener('click', this.onParentDOMClick, true)\n    $child.addEventListener('click', this.onChildDOMClick, false)\n  };\n\n<div onClickCapture={this.onParentClick} style={{padding: '20px', background: 'red'}}>\n  <div className=\"child\" onClick={this.onChildClick} \n  \tstyle={{background: 'green'}}>\n     Demo\n  </div>\n</div>\n")])])]),n("blockquote",[n("p",[e._v("captrue: parent dom event -- bubble: child dom event\n-- capture: parent react event -- captrue: parent dom event")])]),e._v(" "),n("p",[n("strong",[e._v("reason：")])]),e._v(" "),n("ul",[n("li",[e._v("首先原生事件要早于合成事件，另外在原生事件中的事件捕获要早于事件冒泡。")]),e._v(" "),n("li",[e._v("在合成事件中外层元素事件触发要早于内层子元素")])]),e._v(" "),n("h3",{attrs:{id:"常见的一个问题-在合成事件中使用stoppropgation-阻止事件冒泡-默认行为-不生效"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常见的一个问题-在合成事件中使用stoppropgation-阻止事件冒泡-默认行为-不生效"}},[e._v("#")]),e._v(" 常见的一个问题，在合成事件中使用stopPropgation（阻止事件冒泡，默认行为）不生效")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("class SommeComponent extends React.Component {\n\n  handleClick = (e) => {\n    e.stopPropagation();\n  }\n  \n  handleDivClick = () => {\n    console.log('測試冒泡')\n  }\n\n  componentDidMount () {\n    document.body.addEventListener('click', e => {\n      if (e.target.id = 'btn') return;\n      console.log('我是body上的click');\n    })\n  };\n\n  render() {\n    return <>\n      <div onClick={this.handleDivClick}>\n        <p className=\"code\" id='btn' onClick={this.handleClick}>\n          <img src='som.jpg'/>\n        </p>\n      </div>\n  }\n}\n\n")])])]),n("p",[e._v('就以上的例子我们点击p元素，触发了handleClick方法，使用了 e.stopPropagation();可以验证“handleDivClick()”不会有输出，\n但是有意思的是"我是body上的click"依旧输出。')]),e._v(" "),n("p",[n("strong",[e._v("原因分析：")]),e._v('\n使用e.stopPropagation()有效阻止了事件冒泡，所以"handleDivClick()"不会输出，但是这两个事件都是合成事件（且是click类型），意味着在body上会有这个这个click事件，\n所以通过原生事件还是能捕捉到（合成事件中的阻止事件冒泡只能影响合成事件，不能影响原生事件）; 但如果在原生事件中阻止事件冒泡，则会阻止原生/合成事件冒泡。')]),e._v(" "),n("p",[n("strong",[e._v("建议不要将原生事件与合成事件一起使用：")])]),e._v(" "),n("p",[e._v("如果有时候真的没得办法，那我们有以下两种选择方案可以解决：")]),e._v(" "),n("ol",[n("li",[e._v("合理使用e.stopPropagation() 【两个角度原生事件中使用，合成事件中使用】")]),e._v(" "),n("li",[e._v("使用事件对象event.target来判断的信息来判断")])]),e._v(" "),n("h3",{attrs:{id:"在合成事件中怎么获得原生事件对象了"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在合成事件中怎么获得原生事件对象了"}},[e._v("#")]),e._v(" 在合成事件中怎么获得原生事件对象了")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 阻止事件冒泡&捕获\ne.nativeEvent.stopPropagation(); \n\n// 阻止事件冒泡&捕获 && 阻止同一事件的其他绑定执行（一个元素被绑定多个click事件，stopImmediatePropagation使得只会执行一次）\ne.nativeEvent.stopImmediatePropagation();\n")])])]),n("p",[n("a",{attrs:{href:"https://mp.weixin.qq.com/s/NLJlcdhMcPPgrS8KrnmQ9A",target:"_blank",rel:"noopener noreferrer"}},[e._v("合成事件的例子"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("参考：")]),e._v(" "),n("p",[e._v("react官网合成事件：\n"),n("a",{attrs:{href:"https://react-1251415695.cos-website.ap-chengdu.myqcloud.com/docs/events.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://react-1251415695.cos-website.ap-chengdu.myqcloud.com/docs/events.html"),n("OutboundLink")],1)]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.im/post/59db6e7af265da431f4a02ef",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://juejin.im/post/59db6e7af265da431f4a02ef"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports}}]);