# web优化

###### web性能有很多可以优化 ，大致分为： **'度量标准'， '编码优化'， '静态资源优化', '交付优化'， ‘构建优化’， ‘性能检测’。**

## 度量标准，设定目标

#### 度量标准：

- 首次有效绘制（FMP，First Meaningful Paint）

  当主要内容呈现在页面上

- 可交互时间（Time to Interactive）

  页面布局已经稳定，关键的页面字体是可见的，并且进程可用于用户输入，用户可以点击UI并输入所需的时间 

- 输入响应

  洁面后响应用户输入所属的时间

- 感知速度指数 （Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好）

#### 设定目标：

- 100毫秒的界面响应时间与60FPS
- 速度指标（Speed Index）小于1250ms
- 3G网络环境下可交互时间小于5s
- 重要文件的大小预算小于170kb

详细信息请查看RAIL性能模型

## 编码优化

编码优化涉及到应用运行时的性能

#### 数据读取速度

- 字面量与局部变量的访问速度最快，数组元素和对象成员相对较慢
- 变量从局部作用域到全局作用域的搜索过程越长速度越慢
- 对象嵌套的越深，读取速度就越慢
- 对象在原型链中存在的位置越深，找到它的速度就越慢

##### DOM

应用在运行时，性能的瓶颈主要在于DOM操作的代价非常昂贵，下面列出一些关于DOM操作相关提升性能的建议：

- 在JS中对DOM进行访问的代价非常高。请尽可能减少访问DOM的次数（建议缓存DOM属性和元素、把DOM集合的长度缓存到变量中并在迭代中使用。读变量比读DOM的速度要快很多。）
- 重排与重绘的代价非常昂贵。如果操作需要进行多次重排与重绘，建议先让元素脱离文档流，处理完毕后再让元素回归文档流，这样浏览器只会进行两次重排与重绘（脱离时和回归时）。
- 善于使用事件委托

####  流程控制

- 避免使用for...in（它能枚举到原型，所以很慢）
- 减少迭代的次数
- 基于循环的迭代比基于函数的迭代快8倍
- 用Map表代替大量的if-else和switch会提升性能

## 静态资源优化

- 静态资源进行压缩
-  CDN，浏览器缓存
- 异步无阻塞加载JS 【js加载与执行会阻塞渲染，可以将Script标签放到页面的最底部。但是更好的做法是异步无阻塞加载JS】defer、async、动态创建script标签、使用XHR异步请求JS代码并注入到页面。

<https://www.cnblogs.com/evaling/p/10677566.html>

## 交付优化

 使用Intersection Observer实现懒加载

- 可以通过Intersection Observer延迟加载图片、视频、广告脚本、或任何其他资源。
- 可以先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它

> 延迟加载所有体积较大的组件、字体、JS、视频或Iframe是一个好主意

- 快速响应的用户界面

将一个大任务拆分成多个小任务分布在不同的Macrotask中执行（通俗的说是将大的JS任务拆分成多个小任务异步执行）。或者使用WebWorkers，它可以在UI线程外执行JS代码运算，不会阻塞UI线程，所以不会影响用户体验。

## 构建优化

- webpack构建Tree-shaking、Code-splitting

- 服务端渲染（SSR）

- 按需加载， 使用import函数动态导入模块

- 使用HTTP缓存头

  <https://mp.weixin.qq.com/s/C2Zx3KPNPkgj-aHnOY43Iw>

